/* tslint:disable */
/* eslint-disable */
/**
 * Catapult REST Endpoints
 * OpenAPI Specification of catapult-rest
 *
 * The version of the OpenAPI document: 1.0.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, BaseAPI } from './base';
/**
 * Type of account key: * 0 - Unset. * 1 - Linked account public key. * 2 - Node public key on which remote is allowed to harvest. * 4 - VRF public key.
 * @export
 * @enum {string}
 */
export const AccountKeyTypeFlagsEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_4: 4
};
/**
 *
 * @export
 * @enum {string}
 */
export const AccountOrderByEnum = {
    Id: 'id',
    Balance: 'balance'
};
/**
 * Type of account restriction: * 0x0001 (1 decimal) - Allow only incoming transactions from a given address. * 0x0002 (2 decimal) - Allow only incoming transactions containing a given mosaic identifier. * 0x4001 (16385 decimal) - Allow only outgoing transactions to a given address. * 0x4004 (16388 decimal) - Allow only outgoing transactions with a given transaction type. * 0x8001 (32769 decimal) - Block incoming transactions from a given address. * 0x8002 (32770 decimal) - Block incoming transactions containing a given mosaic identifier. * 0xC001 (49153 decimal) - Block outgoing transactions to a given address. * 0xC004 (49156 decimal) - Block outgoing transactions with a given transaction type.
 * @export
 * @enum {string}
 */
export const AccountRestrictionFlagsEnum = {
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_16385: 16385,
    NUMBER_16388: 16388,
    NUMBER_32769: 32769,
    NUMBER_32770: 32770,
    NUMBER_49153: 49153,
    NUMBER_49156: 49156
};
/**
 * * 0 - Unlinked. * 1 - Balance-holding account that is linked to a remote harvester account. * 2 - Remote harvester account that is linked to a balance-holding account. * 3 - Remote harvester eligible account that is unlinked.
 * @export
 * @enum {string}
 */
export const AccountTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3
};
/**
 * Alias action: * 0 - Unlink alias. * 1 - Link alias.
 * @export
 * @enum {string}
 */
export const AliasActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * Type of alias: * 0 - No alias. * 1 - Mosaic id alias. * 2 - Addres alias.
 * @export
 * @enum {string}
 */
export const AliasTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
};
/**
 *
 * @export
 * @enum {string}
 */
export const BlockOrderByEnum = {
    Id: 'id',
    Height: 'height'
};
/**
 * Type of action: * 0 - Unlink. * 1 - Link.
 * @export
 * @enum {string}
 */
export const LinkActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * Algorithm used to hash the proof: * 0 (Op_Sha3_256) - Proof is hashed using SHA3-256. * 1 (Op_Hash_160) - Proof is hashed twice: first with SHA-256 and then with RIPEMD-160 (bitcoin\'s OP_HASH160). * 2 (Op_Hash_256) - Proof is hashed twice with SHA3-256 (bitcoin\'s OP_HASH256).
 * @export
 * @enum {string}
 */
export const LockHashAlgorithmEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
};
/**
 * Possible status of lock states: * 0 - UNUSED. * 1 - USED.
 * @export
 * @enum {string}
 */
export const LockStatus = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * Type of Merkle tree node: * 0 - Branch node. * 255 - Leaf node.
 * @export
 * @enum {string}
 */
export const MerkleTreeNodeTypeEnum = {
    NUMBER_0: 0,
    NUMBER_255: 255
};
/**
 * Metadata type: * 0 - Account. * 1 - Mosaic. * 2 - Namespace.
 * @export
 * @enum {string}
 */
export const MetadataTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
};
/**
 * - 0 - Mosaic address restriction. - 1 - Mosaic global restriction.
 * @export
 * @enum {string}
 */
export const MosaicRestrictionEntryTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * Type of mosaic restriction. * 0 - Uninitialized value indicating no restriction. * 1 (EQ) - Allow if equal. * 2 (NE) - Allow if not equal. * 3 (LT) - Allow if less than. * 4 (LE) - Allow if less than or equal. * 5 (GT) - Allow if greater than. * 6 (GE) - Allow if greater than or equal.
 * @export
 * @enum {string}
 */
export const MosaicRestrictionTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2,
    NUMBER_3: 3,
    NUMBER_4: 4,
    NUMBER_5: 5,
    NUMBER_6: 6
};
/**
 * Direction of the supply change: * 0  - Decrease. * 1  - Increase.
 * @export
 * @enum {string}
 */
export const MosaicSupplyChangeActionEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * Type of namespace: * 0 - Root namespace. * 1 - Subnamespace.
 * @export
 * @enum {string}
 */
export const NamespaceRegistrationTypeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
};
/**
 * Network type: * 0x68 (104 decimal) - Main network. * 0x98 (152 decimal) - Test network.
 * @export
 * @enum {string}
 */
export const NetworkTypeEnum = {
    NUMBER_104: 104,
    NUMBER_152: 152
};
/**
 * Node equality strategy. Defines if the identifier for the node must be its public key or host.
 * @export
 * @enum {string}
 */
export const NodeIdentityEqualityStrategy = {
    Host: 'host',
    PublicKey: 'public-key'
};
/**
 *
 * @export
 * @enum {string}
 */
export const NodeStatusEnum = {
    Up: 'up',
    Down: 'down'
};
/**
 * Indicates how to sort the results:  * ``asc`` - ascending * ``desc`` - descending
 * @export
 * @enum {string}
 */
export const Order = {
    Asc: 'asc',
    Desc: 'desc'
};
/**
 * Position relative to the proofHash being evaluated.
 * @export
 * @enum {string}
 */
export const PositionEnum = {
    Left: 'left',
    Right: 'right'
};
/**
 * Type of receipt: * 0x124D (4685 decimal) - Mosaic_Rental_Fee. * 0x134E (4942 decimal) - Namespace_Rental_Fee. * 0x2143 (8515 decimal) - Harvest_Fee. * 0x2248 (8776 decimal) - LockHash_Completed. * 0x2348 (9032 decimal) - LockHash_Expired. * 0x2252 (8786 decimal) - LockSecret_Completed. * 0x2352 (9042 decimal) - LockSecret_Expired. * 0x3148 (12616 decimal) - LockHash_Created. * 0x3152 (12626 decimal) - LockSecret_Created. * 0x414D (16717 decimal) - Mosaic_Expired. * 0x414E (16718 decimal) - Namespace_Expired. * 0x424E (16974 decimal) - Namespace_Deleted. * 0x5143 (20803 decimal) - Inflation. * 0xE143 (57667 decimal) - Transaction_Group. * 0xF143 (61763 decimal) - Address_Alias_Resolution. * 0xF243 (62019 decimal) - Mosaic_Alias_Resolution.
 * @export
 * @enum {string}
 */
export const ReceiptTypeEnum = {
    NUMBER_4685: 4685,
    NUMBER_4942: 4942,
    NUMBER_8515: 8515,
    NUMBER_8776: 8776,
    NUMBER_9032: 9032,
    NUMBER_8786: 8786,
    NUMBER_9042: 9042,
    NUMBER_12616: 12616,
    NUMBER_12626: 12626,
    NUMBER_16717: 16717,
    NUMBER_16718: 16718,
    NUMBER_16974: 16974,
    NUMBER_20803: 20803,
    NUMBER_57667: 57667,
    NUMBER_61763: 61763,
    NUMBER_62019: 62019
};
/**
 * Type of stage: * 0 - Prevote. * 1 - Precommit. * 2 - Count.
 * @export
 * @enum {string}
 */
export const StageEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1,
    NUMBER_2: 2
};
/**
 * A transaction could be classified in the following groups: * Unconfirmed: The transaction reached the P2P network. At this point, it is not guaranteed that the transaction will be included in a block. * Confirmed: The transaction is included in a block. * Partial: The transaction requires to be cosigned by other transaction participants in order to be included in a block. * Failed: The transaction did not pass the network validation, and it was rejected.
 * @export
 * @enum {string}
 */
export const TransactionGroupEnum = {
    Unconfirmed: 'unconfirmed',
    Confirmed: 'confirmed',
    Failed: 'failed',
    Partial: 'partial'
};
/**
 * List of status errors that can be returned via the status channel after announcing a transaction: * Success * Neutral * Failure * Failure_Core_Past_Deadline - Validation failed because the deadline passed. * Failure_Core_Future_Deadline - Validation failed because the deadline is too far in the future. * Failure_Core_Insufficient_Balance - Validation failed because the account has an insufficient balance. * Failure_Core_Too_Many_Transactions - Validation failed because there are too many transactions in a block. * Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block - Validation failed because an entity originated from the nemesis account after the nemesis block. * Failure_Core_Wrong_Network - Validation failed because the entity has the wrong network specified. * Failure_Core_Invalid_Address - Validation failed because an address is invalid. * Failure_Core_Invalid_Version - Validation failed because entity version is invalid. * Failure_Core_Invalid_Transaction_Fee - Validation failed because a transaction fee is invalid. * Failure_Core_Block_Harvester_Ineligible - Validation failed because a block was harvested by an ineligible harvester. * Failure_Core_Zero_Address - Validation failed because an address is zero. * Failure_Core_Zero_Public_Key - Validation failed because a public key is zero. * Failure_Core_Nonzero_Internal_Padding - Validation failed because internal padding is nonzero. * Failure_Core_Address_Collision - Validation failed because an address collision is detected. * Failure_Core_Importance_Block_Mismatch - Validation failed because the block does not match the schema of an importance block. * Failure_Core_Unexpected_Block_Type - Validation failed because the block type is unexpected. * Failure_Core_Block_Explicit_Transactions_Hash_Mismatch - Validation failed because a block did not have the expected transactions hash at a specified height. * Failure_Core_Invalid_Link_Action - Validation failed because link action is invalid. * Failure_Core_Link_Already_Exists - Validation failed because main account is already linked to another account. * Failure_Core_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link. * Failure_Core_Invalid_Link_Range - Validation failed because link range is invalid. * Failure_Core_Too_Many_Links - Validation failed because main account has too many links of the specified type. * Failure_Core_Link_Start_Epoch_Invalid - Validation failed because the start epoch is invalid. * Failure_Hash_Already_Exists * Failure_Signature_Not_Verifiable - Validation failed because the verification of the signature failed. * Failure_AccountLink_Link_Already_Exists - Validation failed because main account is already linked to another account. * Failure_AccountLink_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing account link. * Failure_AccountLink_Unknown_Link - Validation failed because main account is not linked to another account. * Failure_AccountLink_Remote_Account_Ineligible - Validation failed because link is attempting to convert ineligible account to remote. * Failure_AccountLink_Remote_Account_Signer_Prohibited - Validation failed because remote is not allowed to sign a transaction. * Failure_AccountLink_Remote_Account_Participant_Prohibited - Validation failed because remote is not allowed to participate in the transaction. * Failure_Aggregate_Too_Many_Transactions - Validation failed because aggregate has too many transactions. * Failure_Aggregate_No_Transactions - Validation failed because aggregate does not have any transactions. * Failure_Aggregate_Too_Many_Cosignatures - Validation failed because aggregate has too many cosignatures. * Failure_Aggregate_Redundant_Cosignatures - Validation failed because redundant cosignatures are present. * Failure_Aggregate_Ineligible_Cosignatories - Validation failed because at least one cosignatory is ineligible. * Failure_Aggregate_Missing_Cosignatures - Validation failed because at least one required cosignature is missing. * Failure_Aggregate_Transactions_Hash_Mismatch - Validation failed because the aggregate transactions hash does not match the calculated value. * Failure_LockHash_Invalid_Mosaic_Id - Validation failed because lock does not allow the specified mosaic. * Failure_LockHash_Invalid_Mosaic_Amount - Validation failed because lock does not allow the specified amount. * Failure_LockHash_Hash_Already_Exists - Validation failed because hash is already present in cache. * Failure_LockHash_Unknown_Hash - Validation failed because hash is not present in cache. * Failure_LockHash_Inactive_Hash - Validation failed because hash is inactive. * Failure_LockHash_Invalid_Duration - Validation failed because duration is too long. * Failure_LockSecret_Invalid_Hash_Algorithm - Validation failed because hash algorithm for lock type secret is invalid. * Failure_LockSecret_Hash_Already_Exists - Validation failed because hash is already present in cache. * Failure_LockSecret_Proof_Size_Out_Of_Bounds - Validation failed because proof is too small or too large. * Failure_LockSecret_Secret_Mismatch - Validation failed because secret does not match proof. * Failure_LockSecret_Unknown_Composite_Key - Validation failed because composite key is unknown. * Failure_LockSecret_Inactive_Secret - Validation failed because secret is inactive. * Failure_LockSecret_Hash_Algorithm_Mismatch - Validation failed because hash algorithm does not match. * Failure_LockSecret_Invalid_Duration - Validation failed because duration is too long. * Failure_Metadata_Value_Too_Small - Validation failed because the metadata value is too small. * Failure_Metadata_Value_Too_Large - Validation failed because the metadata value is too large. * Failure_Metadata_Value_Size_Delta_Too_Large - Validation failed because the metadata value size delta is larger in magnitude than the value size. * Failure_Metadata_Value_Size_Delta_Mismatch - Validation failed because the metadata value size delta does not match expected value based on the current state. * Failure_Metadata_Value_Change_Irreversible - Validation failed because a metadata value change (truncation) is irreversible. * Failure_Mosaic_Invalid_Duration - Validation failed because the duration has an invalid value. * Failure_Mosaic_Invalid_Name - Validation failed because the name is invalid. * Failure_Mosaic_Name_Id_Mismatch - Validation failed because the name and id don\'t match. * Failure_Mosaic_Expired - Validation failed because the parent is expired. * Failure_Mosaic_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner. * Failure_Mosaic_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce. * Failure_Mosaic_Parent_Id_Conflict - Validation failed because the existing parent id does not match the supplied parent id. * Failure_Mosaic_Invalid_Property - Validation failed because a mosaic property is invalid. * Failure_Mosaic_Invalid_Flags - Validation failed because the mosaic flags are invalid. * Failure_Mosaic_Invalid_Divisibility - Validation failed because the mosaic divisibility is invalid. * Failure_Mosaic_Invalid_Supply_Change_Action - Validation failed because the mosaic supply change action is invalid. * Failure_Mosaic_Invalid_Supply_Change_Amount - Validation failed because the mosaic supply change amount is invalid. * Failure_Mosaic_Invalid_Id - Validation failed because the mosaic id is invalid. * Failure_Mosaic_Modification_Disallowed - Validation failed because mosaic modification is not allowed. * Failure_Mosaic_Modification_No_Changes - Validation failed because mosaic modification would not result in any changes. * Failure_Mosaic_Supply_Immutable - Validation failed because the mosaic supply is immutable. * Failure_Mosaic_Supply_Negative - Validation failed because the resulting mosaic supply is negative. * Failure_Mosaic_Supply_Exceeded - Validation failed because the resulting mosaic supply exceeds the maximum allowed value. * Failure_Mosaic_Non_Transferable - Validation failed because the mosaic is not transferable. * Failure_Mosaic_Max_Mosaics_Exceeded - Validation failed because the credit of the mosaic would exceed the maximum of different mosaics an account is allowed to own. * Failure_Mosaic_Required_Property_Flag_Unset - Validation failed because the mosaic has at least one required property flag unset. * Failure_Multisig_Account_In_Both_Sets - Validation failed because account is specified to be both added and removed. * Failure_Multisig_Multiple_Deletes - Validation failed because multiple removals are present. * Failure_Multisig_Redundant_Modification - Validation failed because a modification is redundant. * Failure_Multisig_Unknown_Multisig_Account - Validation failed because account is not in multisig cache. * Failure_Multisig_Not_A_Cosignatory - Validation failed because account to be removed is not present. * Failure_Multisig_Already_A_Cosignatory - Validation failed because account to be added is already a cosignatory. * Failure_Multisig_Min_Setting_Out_Of_Range - Validation failed because new minimum settings are out of range. * Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories - Validation failed because min settings are larger than number of cosignatories. * Failure_Multisig_Invalid_Modification_Action - Validation failed because the modification action is invalid. * Failure_Multisig_Max_Cosigned_Accounts - Validation failed because the cosignatory already cosigns the maximum number of accounts. * Failure_Multisig_Max_Cosignatories - Validation failed because the multisig account already has the maximum number of cosignatories. * Failure_Multisig_Loop - Validation failed because a multisig loop is created. * Failure_Multisig_Max_Multisig_Depth - Validation failed because the max multisig depth is exceeded. * Failure_Multisig_Operation_Prohibited_By_Account - Validation failed because an operation is not permitted by a multisig account. * Failure_Namespace_Invalid_Duration - Validation failed because the duration has an invalid value. * Failure_Namespace_Invalid_Name - Validation failed because the name is invalid. * Failure_Namespace_Name_Id_Mismatch - Validation failed because the name and id don\'t match. * Failure_Namespace_Expired - Validation failed because the parent is expired. * Failure_Namespace_Owner_Conflict - Validation failed because the parent owner conflicts with the child owner. * Failure_Namespace_Id_Mismatch - Validation failed because the id is not the expected id generated from signer and nonce. * Failure_Namespace_Invalid_Registration_Type - Validation failed because the namespace registration type is invalid. * Failure_Namespace_Root_Name_Reserved - Validation failed because the root namespace has a reserved name. * Failure_Namespace_Too_Deep - Validation failed because the resulting namespace would exceed the maximum allowed namespace depth. * Failure_Namespace_Unknown_Parent - Validation failed because the namespace parent is unknown. * Failure_Namespace_Already_Exists - Validation failed because the namespace already exists. * Failure_Namespace_Already_Active - Validation failed because the namespace is already active. * Failure_Namespace_Eternal_After_Nemesis_Block - Validation failed because an eternal namespace was received after the nemesis block. * Failure_Namespace_Max_Children_Exceeded - Validation failed because the maximum number of children for a root namespace was exceeded. * Failure_Namespace_Alias_Invalid_Action - Validation failed because alias action is invalid. * Failure_Namespace_Unknown - Validation failed because namespace does not exist. * Failure_Namespace_Alias_Already_Exists - Validation failed because namespace is already linked to an alias. * Failure_Namespace_Unknown_Alias - Validation failed because namespace is not linked to an alias. * Failure_Namespace_Alias_Inconsistent_Unlink_Type - Validation failed because unlink type is not consistent with existing alias. * Failure_Namespace_Alias_Inconsistent_Unlink_Data - Validation failed because unlink data is not consistent with existing alias. * Failure_Namespace_Alias_Invalid_Address - Validation failed because aliased address is invalid. * Failure_RestrictionAccount_Invalid_Restriction_Flags - Validation failed because the account restriction flags are invalid. * Failure_RestrictionAccount_Invalid_Modification_Action - Validation failed because a modification action is invalid. * Failure_RestrictionAccount_Invalid_Modification_Address - Validation failed because a modification address is invalid. * Failure_RestrictionAccount_Modification_Operation_Type_Incompatible - Validation failed because the operation type is incompatible. *Note*: This indicates that the existing restrictions have a different operation type than that specified in the notification. * Failure_RestrictionAccount_Redundant_Modification - Validation failed because a modification is redundant. * Failure_RestrictionAccount_Invalid_Modification - Validation failed because a value is not in the container. * Failure_RestrictionAccount_Modification_Count_Exceeded - Validation failed because the transaction has too many modifications. * Failure_RestrictionAccount_No_Modifications - Validation failed because the transaction has no modifications. * Failure_RestrictionAccount_Values_Count_Exceeded - Validation failed because the resulting account restriction has too many values. * Failure_RestrictionAccount_Invalid_Value - Validation failed because the account restriction value is invalid. * Failure_RestrictionAccount_Address_Interaction_Prohibited - Validation failed because the addresses involved in the transaction are not allowed to interact. * Failure_RestrictionAccount_Mosaic_Transfer_Prohibited - Validation failed because the mosaic transfer is prohibited by the recipient. * Failure_RestrictionAccount_Operation_Type_Prohibited - Validation failed because the operation type is not allowed to be initiated by the signer. * Failure_RestrictionMosaic_Invalid_Restriction_Type - Validation failed because the mosaic restriction type is invalid. * Failure_RestrictionMosaic_Previous_Value_Mismatch - Validation failed because specified previous value does not match current value. * Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero - Validation failed because specified previous value is nonzero. * Failure_RestrictionMosaic_Max_Restrictions_Exceeded - Validation failed because the maximum number of restrictions would be exceeded. * Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction - Validation failed because nonexistent restriction cannot be deleted. * Failure_RestrictionMosaic_Unknown_Global_Restriction - Validation failed because required global restriction does not exist. * Failure_RestrictionMosaic_Invalid_Global_Restriction - Validation failed because mosaic has invalid global restriction. * Failure_RestrictionMosaic_Account_Unauthorized - Validation failed because account lacks proper permissions to move mosaic. * Failure_Transfer_Message_Too_Large - Validation failed because the message is too large. * Failure_Transfer_Out_Of_Order_Mosaics - Validation failed because mosaics are out of order. * Failure_Chain_Unlinked - Validation failed because a block was received that did not link with the existing chain. * Failure_Chain_Block_Not_Hit - Validation failed because a block was received that is not a hit. * Failure_Chain_Block_Inconsistent_State_Hash - Validation failed because a block was received that has an inconsistent state hash. * Failure_Chain_Block_Inconsistent_Receipts_Hash - Validation failed because a block was received that has an inconsistent receipts hash. * Failure_Chain_Block_Invalid_Vrf_Proof - Validation failed because the Vrf proof is invalid. * Failure_Chain_Block_Unknown_Signer - Validation failed because the block signer is unknown. * Failure_Chain_Unconfirmed_Cache_Too_Full - Validation failed because the unconfirmed cache is too full. * Failure_Consumer_Empty_Input - Validation failed because the consumer input is empty. * Failure_Consumer_Block_Transactions_Hash_Mismatch - Validation failed because the block transactions hash does not match the calculated value. * Neutral_Consumer_Hash_In_Recency_Cache - Validation failed because an entity hash is present in the recency cache. * Failure_Consumer_Remote_Chain_Too_Many_Blocks - Validation failed because the chain part has too many blocks. * Failure_Consumer_Remote_Chain_Improper_Link - Validation failed because the chain is internally improperly linked. * Failure_Consumer_Remote_Chain_Duplicate_Transactions - Validation failed because the chain part contains duplicate transactions. * Failure_Consumer_Remote_Chain_Unlinked - Validation failed because the chain part does not link to the current chain. * Failure_Consumer_Remote_Chain_Difficulties_Mismatch - Validation failed because the remote chain difficulties do not match the calculated difficulties. * Failure_Consumer_Remote_Chain_Score_Not_Better - Validation failed because the remote chain score is not better. * Failure_Consumer_Remote_Chain_Too_Far_Behind - Validation failed because the remote chain is too far behind. * Failure_Consumer_Remote_Chain_Too_Far_In_Future - Validation failed because the remote chain timestamp is too far in the future. * Failure_Consumer_Batch_Signature_Not_Verifiable - Validation failed because the verification of the signature failed during a batch operation. * Failure_Consumer_Remote_Chain_Improper_Importance_Link - Validation failed because the remote chain has an improper importance link. * Failure_Extension_Partial_Transaction_Cache_Prune - Validation failed because the partial transaction was pruned from the temporal cache. * Failure_Extension_Partial_Transaction_Dependency_Removed - Validation failed because the partial transaction was pruned from the temporal cache due to its dependency being removed. * Failure_Extension_Read_Rate_Limit_Exceeded - Validation failed because socket read rate limit was exceeded.
 * @export
 * @enum {string}
 */
export const TransactionStatusEnum = {
    Success: 'Success',
    Neutral: 'Neutral',
    Failure: 'Failure',
    FailureCorePastDeadline: 'Failure_Core_Past_Deadline',
    FailureCoreFutureDeadline: 'Failure_Core_Future_Deadline',
    FailureCoreInsufficientBalance: 'Failure_Core_Insufficient_Balance',
    FailureCoreTooManyTransactions: 'Failure_Core_Too_Many_Transactions',
    FailureCoreNemesisAccountSignedAfterNemesisBlock: 'Failure_Core_Nemesis_Account_Signed_After_Nemesis_Block',
    FailureCoreWrongNetwork: 'Failure_Core_Wrong_Network',
    FailureCoreInvalidAddress: 'Failure_Core_Invalid_Address',
    FailureCoreInvalidVersion: 'Failure_Core_Invalid_Version',
    FailureCoreInvalidTransactionFee: 'Failure_Core_Invalid_Transaction_Fee',
    FailureCoreBlockHarvesterIneligible: 'Failure_Core_Block_Harvester_Ineligible',
    FailureCoreZeroAddress: 'Failure_Core_Zero_Address',
    FailureCoreZeroPublicKey: 'Failure_Core_Zero_Public_Key',
    FailureCoreNonzeroInternalPadding: 'Failure_Core_Nonzero_Internal_Padding',
    FailureCoreAddressCollision: 'Failure_Core_Address_Collision',
    FailureCoreImportanceBlockMismatch: 'Failure_Core_Importance_Block_Mismatch',
    FailureCoreUnexpectedBlockType: 'Failure_Core_Unexpected_Block_Type',
    FailureCoreBlockExplicitTransactionsHashMismatch: 'Failure_Core_Block_Explicit_Transactions_Hash_Mismatch',
    FailureCoreInvalidLinkAction: 'Failure_Core_Invalid_Link_Action',
    FailureCoreLinkAlreadyExists: 'Failure_Core_Link_Already_Exists',
    FailureCoreInconsistentUnlinkData: 'Failure_Core_Inconsistent_Unlink_Data',
    FailureCoreInvalidLinkRange: 'Failure_Core_Invalid_Link_Range',
    FailureCoreTooManyLinks: 'Failure_Core_Too_Many_Links',
    FailureCoreLinkStartEpochInvalid: 'Failure_Core_Link_Start_Epoch_Invalid',
    FailureHashAlreadyExists: 'Failure_Hash_Already_Exists',
    FailureSignatureNotVerifiable: 'Failure_Signature_Not_Verifiable',
    FailureAccountLinkLinkAlreadyExists: 'Failure_AccountLink_Link_Already_Exists',
    FailureAccountLinkInconsistentUnlinkData: 'Failure_AccountLink_Inconsistent_Unlink_Data',
    FailureAccountLinkUnknownLink: 'Failure_AccountLink_Unknown_Link',
    FailureAccountLinkRemoteAccountIneligible: 'Failure_AccountLink_Remote_Account_Ineligible',
    FailureAccountLinkRemoteAccountSignerProhibited: 'Failure_AccountLink_Remote_Account_Signer_Prohibited',
    FailureAccountLinkRemoteAccountParticipantProhibited: 'Failure_AccountLink_Remote_Account_Participant_Prohibited',
    FailureAggregateTooManyTransactions: 'Failure_Aggregate_Too_Many_Transactions',
    FailureAggregateNoTransactions: 'Failure_Aggregate_No_Transactions',
    FailureAggregateTooManyCosignatures: 'Failure_Aggregate_Too_Many_Cosignatures',
    FailureAggregateRedundantCosignatures: 'Failure_Aggregate_Redundant_Cosignatures',
    FailureAggregateIneligibleCosignatories: 'Failure_Aggregate_Ineligible_Cosignatories',
    FailureAggregateMissingCosignatures: 'Failure_Aggregate_Missing_Cosignatures',
    FailureAggregateTransactionsHashMismatch: 'Failure_Aggregate_Transactions_Hash_Mismatch',
    FailureLockHashInvalidMosaicId: 'Failure_LockHash_Invalid_Mosaic_Id',
    FailureLockHashInvalidMosaicAmount: 'Failure_LockHash_Invalid_Mosaic_Amount',
    FailureLockHashHashAlreadyExists: 'Failure_LockHash_Hash_Already_Exists',
    FailureLockHashUnknownHash: 'Failure_LockHash_Unknown_Hash',
    FailureLockHashInactiveHash: 'Failure_LockHash_Inactive_Hash',
    FailureLockHashInvalidDuration: 'Failure_LockHash_Invalid_Duration',
    FailureLockSecretInvalidHashAlgorithm: 'Failure_LockSecret_Invalid_Hash_Algorithm',
    FailureLockSecretHashAlreadyExists: 'Failure_LockSecret_Hash_Already_Exists',
    FailureLockSecretProofSizeOutOfBounds: 'Failure_LockSecret_Proof_Size_Out_Of_Bounds',
    FailureLockSecretSecretMismatch: 'Failure_LockSecret_Secret_Mismatch',
    FailureLockSecretUnknownCompositeKey: 'Failure_LockSecret_Unknown_Composite_Key',
    FailureLockSecretInactiveSecret: 'Failure_LockSecret_Inactive_Secret',
    FailureLockSecretHashAlgorithmMismatch: 'Failure_LockSecret_Hash_Algorithm_Mismatch',
    FailureLockSecretInvalidDuration: 'Failure_LockSecret_Invalid_Duration',
    FailureMetadataValueTooSmall: 'Failure_Metadata_Value_Too_Small',
    FailureMetadataValueTooLarge: 'Failure_Metadata_Value_Too_Large',
    FailureMetadataValueSizeDeltaTooLarge: 'Failure_Metadata_Value_Size_Delta_Too_Large',
    FailureMetadataValueSizeDeltaMismatch: 'Failure_Metadata_Value_Size_Delta_Mismatch',
    FailureMetadataValueChangeIrreversible: 'Failure_Metadata_Value_Change_Irreversible',
    FailureMosaicInvalidDuration: 'Failure_Mosaic_Invalid_Duration',
    FailureMosaicInvalidName: 'Failure_Mosaic_Invalid_Name',
    FailureMosaicNameIdMismatch: 'Failure_Mosaic_Name_Id_Mismatch',
    FailureMosaicExpired: 'Failure_Mosaic_Expired',
    FailureMosaicOwnerConflict: 'Failure_Mosaic_Owner_Conflict',
    FailureMosaicIdMismatch: 'Failure_Mosaic_Id_Mismatch',
    FailureMosaicParentIdConflict: 'Failure_Mosaic_Parent_Id_Conflict',
    FailureMosaicInvalidProperty: 'Failure_Mosaic_Invalid_Property',
    FailureMosaicInvalidFlags: 'Failure_Mosaic_Invalid_Flags',
    FailureMosaicInvalidDivisibility: 'Failure_Mosaic_Invalid_Divisibility',
    FailureMosaicInvalidSupplyChangeAction: 'Failure_Mosaic_Invalid_Supply_Change_Action',
    FailureMosaicInvalidSupplyChangeAmount: 'Failure_Mosaic_Invalid_Supply_Change_Amount',
    FailureMosaicInvalidId: 'Failure_Mosaic_Invalid_Id',
    FailureMosaicModificationDisallowed: 'Failure_Mosaic_Modification_Disallowed',
    FailureMosaicModificationNoChanges: 'Failure_Mosaic_Modification_No_Changes',
    FailureMosaicSupplyImmutable: 'Failure_Mosaic_Supply_Immutable',
    FailureMosaicSupplyNegative: 'Failure_Mosaic_Supply_Negative',
    FailureMosaicSupplyExceeded: 'Failure_Mosaic_Supply_Exceeded',
    FailureMosaicNonTransferable: 'Failure_Mosaic_Non_Transferable',
    FailureMosaicMaxMosaicsExceeded: 'Failure_Mosaic_Max_Mosaics_Exceeded',
    FailureMosaicRequiredPropertyFlagUnset: 'Failure_Mosaic_Required_Property_Flag_Unset',
    FailureMultisigAccountInBothSets: 'Failure_Multisig_Account_In_Both_Sets',
    FailureMultisigMultipleDeletes: 'Failure_Multisig_Multiple_Deletes',
    FailureMultisigRedundantModification: 'Failure_Multisig_Redundant_Modification',
    FailureMultisigUnknownMultisigAccount: 'Failure_Multisig_Unknown_Multisig_Account',
    FailureMultisigNotACosignatory: 'Failure_Multisig_Not_A_Cosignatory',
    FailureMultisigAlreadyACosignatory: 'Failure_Multisig_Already_A_Cosignatory',
    FailureMultisigMinSettingOutOfRange: 'Failure_Multisig_Min_Setting_Out_Of_Range',
    FailureMultisigMinSettingLargerThanNumCosignatories: 'Failure_Multisig_Min_Setting_Larger_Than_Num_Cosignatories',
    FailureMultisigInvalidModificationAction: 'Failure_Multisig_Invalid_Modification_Action',
    FailureMultisigMaxCosignedAccounts: 'Failure_Multisig_Max_Cosigned_Accounts',
    FailureMultisigMaxCosignatories: 'Failure_Multisig_Max_Cosignatories',
    FailureMultisigLoop: 'Failure_Multisig_Loop',
    FailureMultisigMaxMultisigDepth: 'Failure_Multisig_Max_Multisig_Depth',
    FailureMultisigOperationProhibitedByAccount: 'Failure_Multisig_Operation_Prohibited_By_Account',
    FailureNamespaceInvalidDuration: 'Failure_Namespace_Invalid_Duration',
    FailureNamespaceInvalidName: 'Failure_Namespace_Invalid_Name',
    FailureNamespaceNameIdMismatch: 'Failure_Namespace_Name_Id_Mismatch',
    FailureNamespaceExpired: 'Failure_Namespace_Expired',
    FailureNamespaceOwnerConflict: 'Failure_Namespace_Owner_Conflict',
    FailureNamespaceIdMismatch: 'Failure_Namespace_Id_Mismatch',
    FailureNamespaceInvalidRegistrationType: 'Failure_Namespace_Invalid_Registration_Type',
    FailureNamespaceRootNameReserved: 'Failure_Namespace_Root_Name_Reserved',
    FailureNamespaceTooDeep: 'Failure_Namespace_Too_Deep',
    FailureNamespaceUnknownParent: 'Failure_Namespace_Unknown_Parent',
    FailureNamespaceAlreadyExists: 'Failure_Namespace_Already_Exists',
    FailureNamespaceAlreadyActive: 'Failure_Namespace_Already_Active',
    FailureNamespaceEternalAfterNemesisBlock: 'Failure_Namespace_Eternal_After_Nemesis_Block',
    FailureNamespaceMaxChildrenExceeded: 'Failure_Namespace_Max_Children_Exceeded',
    FailureNamespaceAliasInvalidAction: 'Failure_Namespace_Alias_Invalid_Action',
    FailureNamespaceUnknown: 'Failure_Namespace_Unknown',
    FailureNamespaceAliasAlreadyExists: 'Failure_Namespace_Alias_Already_Exists',
    FailureNamespaceUnknownAlias: 'Failure_Namespace_Unknown_Alias',
    FailureNamespaceAliasInconsistentUnlinkType: 'Failure_Namespace_Alias_Inconsistent_Unlink_Type',
    FailureNamespaceAliasInconsistentUnlinkData: 'Failure_Namespace_Alias_Inconsistent_Unlink_Data',
    FailureNamespaceAliasInvalidAddress: 'Failure_Namespace_Alias_Invalid_Address',
    FailureRestrictionAccountInvalidRestrictionFlags: 'Failure_RestrictionAccount_Invalid_Restriction_Flags',
    FailureRestrictionAccountInvalidModificationAction: 'Failure_RestrictionAccount_Invalid_Modification_Action',
    FailureRestrictionAccountInvalidModificationAddress: 'Failure_RestrictionAccount_Invalid_Modification_Address',
    FailureRestrictionAccountModificationOperationTypeIncompatible: 'Failure_RestrictionAccount_Modification_Operation_Type_Incompatible',
    FailureRestrictionAccountRedundantModification: 'Failure_RestrictionAccount_Redundant_Modification',
    FailureRestrictionAccountInvalidModification: 'Failure_RestrictionAccount_Invalid_Modification',
    FailureRestrictionAccountModificationCountExceeded: 'Failure_RestrictionAccount_Modification_Count_Exceeded',
    FailureRestrictionAccountNoModifications: 'Failure_RestrictionAccount_No_Modifications',
    FailureRestrictionAccountValuesCountExceeded: 'Failure_RestrictionAccount_Values_Count_Exceeded',
    FailureRestrictionAccountInvalidValue: 'Failure_RestrictionAccount_Invalid_Value',
    FailureRestrictionAccountAddressInteractionProhibited: 'Failure_RestrictionAccount_Address_Interaction_Prohibited',
    FailureRestrictionAccountMosaicTransferProhibited: 'Failure_RestrictionAccount_Mosaic_Transfer_Prohibited',
    FailureRestrictionAccountOperationTypeProhibited: 'Failure_RestrictionAccount_Operation_Type_Prohibited',
    FailureRestrictionMosaicInvalidRestrictionType: 'Failure_RestrictionMosaic_Invalid_Restriction_Type',
    FailureRestrictionMosaicPreviousValueMismatch: 'Failure_RestrictionMosaic_Previous_Value_Mismatch',
    FailureRestrictionMosaicPreviousValueMustBeZero: 'Failure_RestrictionMosaic_Previous_Value_Must_Be_Zero',
    FailureRestrictionMosaicMaxRestrictionsExceeded: 'Failure_RestrictionMosaic_Max_Restrictions_Exceeded',
    FailureRestrictionMosaicCannotDeleteNonexistentRestriction: 'Failure_RestrictionMosaic_Cannot_Delete_Nonexistent_Restriction',
    FailureRestrictionMosaicUnknownGlobalRestriction: 'Failure_RestrictionMosaic_Unknown_Global_Restriction',
    FailureRestrictionMosaicInvalidGlobalRestriction: 'Failure_RestrictionMosaic_Invalid_Global_Restriction',
    FailureRestrictionMosaicAccountUnauthorized: 'Failure_RestrictionMosaic_Account_Unauthorized',
    FailureTransferMessageTooLarge: 'Failure_Transfer_Message_Too_Large',
    FailureTransferOutOfOrderMosaics: 'Failure_Transfer_Out_Of_Order_Mosaics',
    FailureChainUnlinked: 'Failure_Chain_Unlinked',
    FailureChainBlockNotHit: 'Failure_Chain_Block_Not_Hit',
    FailureChainBlockInconsistentStateHash: 'Failure_Chain_Block_Inconsistent_State_Hash',
    FailureChainBlockInconsistentReceiptsHash: 'Failure_Chain_Block_Inconsistent_Receipts_Hash',
    FailureChainBlockInvalidVrfProof: 'Failure_Chain_Block_Invalid_Vrf_Proof',
    FailureChainBlockUnknownSigner: 'Failure_Chain_Block_Unknown_Signer',
    FailureChainUnconfirmedCacheTooFull: 'Failure_Chain_Unconfirmed_Cache_Too_Full',
    FailureConsumerEmptyInput: 'Failure_Consumer_Empty_Input',
    FailureConsumerBlockTransactionsHashMismatch: 'Failure_Consumer_Block_Transactions_Hash_Mismatch',
    NeutralConsumerHashInRecencyCache: 'Neutral_Consumer_Hash_In_Recency_Cache',
    FailureConsumerRemoteChainTooManyBlocks: 'Failure_Consumer_Remote_Chain_Too_Many_Blocks',
    FailureConsumerRemoteChainImproperLink: 'Failure_Consumer_Remote_Chain_Improper_Link',
    FailureConsumerRemoteChainDuplicateTransactions: 'Failure_Consumer_Remote_Chain_Duplicate_Transactions',
    FailureConsumerRemoteChainUnlinked: 'Failure_Consumer_Remote_Chain_Unlinked',
    FailureConsumerRemoteChainDifficultiesMismatch: 'Failure_Consumer_Remote_Chain_Difficulties_Mismatch',
    FailureConsumerRemoteChainScoreNotBetter: 'Failure_Consumer_Remote_Chain_Score_Not_Better',
    FailureConsumerRemoteChainTooFarBehind: 'Failure_Consumer_Remote_Chain_Too_Far_Behind',
    FailureConsumerRemoteChainTooFarInFuture: 'Failure_Consumer_Remote_Chain_Too_Far_In_Future',
    FailureConsumerBatchSignatureNotVerifiable: 'Failure_Consumer_Batch_Signature_Not_Verifiable',
    FailureConsumerRemoteChainImproperImportanceLink: 'Failure_Consumer_Remote_Chain_Improper_Importance_Link',
    FailureExtensionPartialTransactionCachePrune: 'Failure_Extension_Partial_Transaction_Cache_Prune',
    FailureExtensionPartialTransactionDependencyRemoved: 'Failure_Extension_Partial_Transaction_Dependency_Removed',
    FailureExtensionReadRateLimitExceeded: 'Failure_Extension_Read_Rate_Limit_Exceeded'
};
/**
 * Type of transaction: * 0x414C (16716 decimal) - AccountKeyLinkTransaction. * 0x4243 (16963 decimal) - VrfKeyLinkTransaction. * 0x4143 (16707 decimal) - VotingKeyLinkTransaction. * 0x424C (16972 decimal) - NodeKeyLinkTransaction. * 0x4141 (16705 decimal) - AggregateCompleteTransaction. * 0x4241 (16961 decimal) - AggregateBondedTransaction. * 0x414D (16717 decimal) - MosaicDefinitionTransaction. * 0x424D (16973 decimal) - MosaicSupplyChangeTransaction. * 0x434D (17229 decimal) - MosaicSupplyRevocationTransaction. * 0x414E (16718 decimal) - NamespaceRegistrationTransaction. * 0x424E (16974 decimal) - AddressAliasTransaction. * 0x434E (17230 decimal) - MosaicAliasTransaction. * 0x4144 (16708 decimal) - AccountMetadataTransaction. * 0x4244 (16964 decimal) - MosaicMetadataTransaction. * 0x4344 (17220 decimal) - NamespaceMetadataTransaction. * 0x4155 (16725 decimal) - MultisigAccountModificationTransaction. * 0x4148 (16712 decimal) - HashLockTransaction. * 0x4152 (16722 decimal) - SecretLockTransaction. * 0x4252 (16978 decimal) - SecretProofTransaction. * 0x4150 (16720 decimal) - AccountAddressRestrictionTransaction. * 0x4250 (16976 decimal) - AccountMosaicRestrictionTransaction. * 0x4350 (17232 decimal) - AccountOperationRestrictionTransaction. * 0x4151 (16721 decimal) - MosaicGlobalRestrictionTransaction. * 0x4251 (16977 decimal) - MosaicAddressRestrictionTransaction. * 0x4154 (16724 decimal) - TransferTransaction.
 * @export
 * @enum {string}
 */
export const TransactionTypeEnum = {
    NUMBER_16716: 16716,
    NUMBER_16963: 16963,
    NUMBER_16707: 16707,
    NUMBER_16972: 16972,
    NUMBER_16705: 16705,
    NUMBER_16961: 16961,
    NUMBER_16717: 16717,
    NUMBER_16973: 16973,
    NUMBER_17229: 17229,
    NUMBER_16718: 16718,
    NUMBER_16974: 16974,
    NUMBER_17230: 17230,
    NUMBER_16708: 16708,
    NUMBER_16964: 16964,
    NUMBER_17220: 17220,
    NUMBER_16725: 16725,
    NUMBER_16712: 16712,
    NUMBER_16722: 16722,
    NUMBER_16978: 16978,
    NUMBER_16720: 16720,
    NUMBER_16976: 16976,
    NUMBER_17232: 17232,
    NUMBER_16721: 16721,
    NUMBER_16977: 16977,
    NUMBER_16724: 16724
};
/**
 * AccountRoutesApi - axios parameter creator
 * @export
 */
export const AccountRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the account information.
         * @summary Get account information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo: async (accountId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountInfo', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account merkle information.
         * @summary Get account merkle information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfoMerkle: async (accountId, options = {}) => {
            // verify required parameter 'accountId' is not null or undefined
            assertParamExists('getAccountInfoMerkle', 'accountId', accountId);
            const localVarPath = `/accounts/{accountId}/merkle`
                .replace(`{${"accountId"}}`, encodeURIComponent(String(accountId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account information for an array of accounts.
         * @summary Get accounts information
         * @param {AccountIds} [accountIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsInfo: async (accountIds, options = {}) => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(accountIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of accounts.
         * @summary Search accounts
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {AccountOrderByEnum} [orderBy] Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter.
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts: async (pageSize, pageNumber, offset, order, orderBy, mosaicId, options = {}) => {
            const localVarPath = `/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }
            if (mosaicId !== undefined) {
                localVarQueryParameter['mosaicId'] = mosaicId;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * AccountRoutesApi - functional programming interface
 * @export
 */
export const AccountRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = AccountRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the account information.
         * @summary Get account information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInfo(accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfo(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account merkle information.
         * @summary Get account merkle information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountInfoMerkle(accountId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountInfoMerkle(accountId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account information for an array of accounts.
         * @summary Get accounts information
         * @param {AccountIds} [accountIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsInfo(accountIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsInfo(accountIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of accounts.
         * @summary Search accounts
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {AccountOrderByEnum} [orderBy] Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter.
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * AccountRoutesApi - factory interface
 * @export
 */
export const AccountRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = AccountRoutesApiFp(configuration);
    return {
        /**
         * Returns the account information.
         * @summary Get account information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfo(accountId, options) {
            return localVarFp.getAccountInfo(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account merkle information.
         * @summary Get account merkle information
         * @param {string} accountId Account public key or address encoded using a 32-character set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountInfoMerkle(accountId, options) {
            return localVarFp.getAccountInfoMerkle(accountId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account information for an array of accounts.
         * @summary Get accounts information
         * @param {AccountIds} [accountIds]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsInfo(accountIds, options) {
            return localVarFp.getAccountsInfo(accountIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of accounts.
         * @summary Search accounts
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {AccountOrderByEnum} [orderBy] Sort responses by the property set. If &#x60;&#x60;balance&#x60;&#x60; option is selected, the request must define the &#x60;&#x60;mosaicId&#x60;&#x60; filter.
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId, options) {
            return localVarFp.searchAccounts(pageSize, pageNumber, offset, order, orderBy, mosaicId, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * AccountRoutesApi - object-oriented interface
 * @export
 * @class AccountRoutesApi
 * @extends {BaseAPI}
 */
export class AccountRoutesApi extends BaseAPI {
    /**
     * Returns the account information.
     * @summary Get account information
     * @param {AccountRoutesApiGetAccountInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    getAccountInfo(requestParameters, options) {
        return AccountRoutesApiFp(this.configuration).getAccountInfo(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the account merkle information.
     * @summary Get account merkle information
     * @param {AccountRoutesApiGetAccountInfoMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    getAccountInfoMerkle(requestParameters, options) {
        return AccountRoutesApiFp(this.configuration).getAccountInfoMerkle(requestParameters.accountId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the account information for an array of accounts.
     * @summary Get accounts information
     * @param {AccountRoutesApiGetAccountsInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    getAccountsInfo(requestParameters = {}, options) {
        return AccountRoutesApiFp(this.configuration).getAccountsInfo(requestParameters.accountIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of accounts.
     * @summary Search accounts
     * @param {AccountRoutesApiSearchAccountsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountRoutesApi
     */
    searchAccounts(requestParameters = {}, options) {
        return AccountRoutesApiFp(this.configuration).searchAccounts(requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, requestParameters.orderBy, requestParameters.mosaicId, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * BlockRoutesApi - axios parameter creator
 * @export
 */
export const BlockRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets a block from the chain that has the given height.
         * @summary Get block information
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight: async (height, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getBlockByHeight', 'height', height);
            const localVarPath = `/blocks/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block.
         * @summary Get the merkle path for a given a receipt statement hash and block
         * @param {string} height Block height.
         * @param {string} hash Receipt hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleReceipts: async (height, hash, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getMerkleReceipts', 'height', height);
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getMerkleReceipts', 'hash', hash);
            const localVarPath = `/blocks/{height}/statements/{hash}/merkle`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block.
         * @summary Get the merkle path for a given a transaction and block
         * @param {string} height Block height.
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleTransaction: async (height, hash, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getMerkleTransaction', 'height', height);
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getMerkleTransaction', 'hash', hash);
            const localVarPath = `/blocks/{height}/transactions/{hash}/merkle`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)))
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of bocks.
         * @summary Search blocks
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [beneficiaryAddress] Filter by beneficiary address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {BlockOrderByEnum} [orderBy] Sort responses by the property set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBlocks: async (signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options = {}) => {
            const localVarPath = `/blocks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }
            if (beneficiaryAddress !== undefined) {
                localVarQueryParameter['beneficiaryAddress'] = beneficiaryAddress;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            if (orderBy !== undefined) {
                localVarQueryParameter['orderBy'] = orderBy;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * BlockRoutesApi - functional programming interface
 * @export
 */
export const BlockRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = BlockRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets a block from the chain that has the given height.
         * @summary Get block information
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getBlockByHeight(height, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getBlockByHeight(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block.
         * @summary Get the merkle path for a given a receipt statement hash and block
         * @param {string} height Block height.
         * @param {string} hash Receipt hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerkleReceipts(height, hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerkleReceipts(height, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block.
         * @summary Get the merkle path for a given a transaction and block
         * @param {string} height Block height.
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMerkleTransaction(height, hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMerkleTransaction(height, hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of bocks.
         * @summary Search blocks
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [beneficiaryAddress] Filter by beneficiary address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {BlockOrderByEnum} [orderBy] Sort responses by the property set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * BlockRoutesApi - factory interface
 * @export
 */
export const BlockRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = BlockRoutesApiFp(configuration);
    return {
        /**
         * Gets a block from the chain that has the given height.
         * @summary Get block information
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getBlockByHeight(height, options) {
            return localVarFp.getBlockByHeight(height, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block.
         * @summary Get the merkle path for a given a receipt statement hash and block
         * @param {string} height Block height.
         * @param {string} hash Receipt hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleReceipts(height, hash, options) {
            return localVarFp.getMerkleReceipts(height, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block.
         * @summary Get the merkle path for a given a transaction and block
         * @param {string} height Block height.
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMerkleTransaction(height, hash, options) {
            return localVarFp.getMerkleTransaction(height, hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of bocks.
         * @summary Search blocks
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [beneficiaryAddress] Filter by beneficiary address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {BlockOrderByEnum} [orderBy] Sort responses by the property set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options) {
            return localVarFp.searchBlocks(signerPublicKey, beneficiaryAddress, pageSize, pageNumber, offset, order, orderBy, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * BlockRoutesApi - object-oriented interface
 * @export
 * @class BlockRoutesApi
 * @extends {BaseAPI}
 */
export class BlockRoutesApi extends BaseAPI {
    /**
     * Gets a block from the chain that has the given height.
     * @summary Get block information
     * @param {BlockRoutesApiGetBlockByHeightRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    getBlockByHeight(requestParameters, options) {
        return BlockRoutesApiFp(this.configuration).getBlockByHeight(requestParameters.height, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the merkle path for a receipt statement or resolution linked to a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.receiptsHash) to verify if the statement was linked with the block.
     * @summary Get the merkle path for a given a receipt statement hash and block
     * @param {BlockRoutesApiGetMerkleReceiptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    getMerkleReceipts(requestParameters, options) {
        return BlockRoutesApiFp(this.configuration).getMerkleReceipts(requestParameters.height, requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the merkle path for a transaction included in a block. The merkle path is the minimum number of nodes needed to calculate the merkle root.  Steps to calculate the merkle root: 1. proofHash = hash (leaf). 2. Concatenate proofHash with the first unprocessed item from the merklePath list as follows: * a) If item.position == left -> proofHash = sha_256(item.hash + proofHash). * b) If item.position == right -> proofHash = sha_256(proofHash+ item.hash). 3. Repeat 2. for every item in the merklePath list. 4. Compare if the calculated proofHash equals the one recorded in the block header (block.transactionsHash) to verify if the transaction was included in the block.
     * @summary Get the merkle path for a given a transaction and block
     * @param {BlockRoutesApiGetMerkleTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    getMerkleTransaction(requestParameters, options) {
        return BlockRoutesApiFp(this.configuration).getMerkleTransaction(requestParameters.height, requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of bocks.
     * @summary Search blocks
     * @param {BlockRoutesApiSearchBlocksRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof BlockRoutesApi
     */
    searchBlocks(requestParameters = {}, options) {
        return BlockRoutesApiFp(this.configuration).searchBlocks(requestParameters.signerPublicKey, requestParameters.beneficiaryAddress, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, requestParameters.orderBy, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ChainRoutesApi - axios parameter creator
 * @export
 */
export const ChainRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty − time elapsed since last block
         * @summary Get the current information of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo: async (options = {}) => {
            const localVarPath = `/chain/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ChainRoutesApi - functional programming interface
 * @export
 */
export const ChainRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ChainRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty − time elapsed since last block
         * @summary Get the current information of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChainInfo(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChainInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ChainRoutesApi - factory interface
 * @export
 */
export const ChainRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ChainRoutesApiFp(configuration);
    return {
        /**
         * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty − time elapsed since last block
         * @summary Get the current information of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChainInfo(options) {
            return localVarFp.getChainInfo(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ChainRoutesApi - object-oriented interface
 * @export
 * @class ChainRoutesApi
 * @extends {BaseAPI}
 */
export class ChainRoutesApi extends BaseAPI {
    /**
     * Returns the current information of the blockchain.  The higher the score, the better the chain. During synchronization, nodes try to get the best blockchain in the network.  The score for a block is derived from its difficulty and the time (in seconds) that has elapsed since the last block:      block score = difficulty − time elapsed since last block
     * @summary Get the current information of the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChainRoutesApi
     */
    getChainInfo(options) {
        return ChainRoutesApiFp(this.configuration).getChainInfo(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * FinalizationRoutesApi - axios parameter creator
 * @export
 */
export const FinalizationRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets finalization proof for the greatest height associated with the given epoch.
         * @summary Get finalization proof
         * @param {number} epoch Finalization epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtEpoch: async (epoch, options = {}) => {
            // verify required parameter 'epoch' is not null or undefined
            assertParamExists('getFinalizationProofAtEpoch', 'epoch', epoch);
            const localVarPath = `/finalization/proof/epoch/{epoch}`
                .replace(`{${"epoch"}}`, encodeURIComponent(String(epoch)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets finalization proof at the given height.
         * @summary Get finalization proof
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtHeight: async (height, options = {}) => {
            // verify required parameter 'height' is not null or undefined
            assertParamExists('getFinalizationProofAtHeight', 'height', height);
            const localVarPath = `/finalization/proof/height/{height}`
                .replace(`{${"height"}}`, encodeURIComponent(String(height)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * FinalizationRoutesApi - functional programming interface
 * @export
 */
export const FinalizationRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = FinalizationRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets finalization proof for the greatest height associated with the given epoch.
         * @summary Get finalization proof
         * @param {number} epoch Finalization epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinalizationProofAtEpoch(epoch, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinalizationProofAtEpoch(epoch, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets finalization proof at the given height.
         * @summary Get finalization proof
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFinalizationProofAtHeight(height, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFinalizationProofAtHeight(height, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * FinalizationRoutesApi - factory interface
 * @export
 */
export const FinalizationRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = FinalizationRoutesApiFp(configuration);
    return {
        /**
         * Gets finalization proof for the greatest height associated with the given epoch.
         * @summary Get finalization proof
         * @param {number} epoch Finalization epoch.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtEpoch(epoch, options) {
            return localVarFp.getFinalizationProofAtEpoch(epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets finalization proof at the given height.
         * @summary Get finalization proof
         * @param {string} height Block height.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFinalizationProofAtHeight(height, options) {
            return localVarFp.getFinalizationProofAtHeight(height, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * FinalizationRoutesApi - object-oriented interface
 * @export
 * @class FinalizationRoutesApi
 * @extends {BaseAPI}
 */
export class FinalizationRoutesApi extends BaseAPI {
    /**
     * Gets finalization proof for the greatest height associated with the given epoch.
     * @summary Get finalization proof
     * @param {FinalizationRoutesApiGetFinalizationProofAtEpochRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinalizationRoutesApi
     */
    getFinalizationProofAtEpoch(requestParameters, options) {
        return FinalizationRoutesApiFp(this.configuration).getFinalizationProofAtEpoch(requestParameters.epoch, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets finalization proof at the given height.
     * @summary Get finalization proof
     * @param {FinalizationRoutesApiGetFinalizationProofAtHeightRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FinalizationRoutesApi
     */
    getFinalizationProofAtHeight(requestParameters, options) {
        return FinalizationRoutesApiFp(this.configuration).getFinalizationProofAtHeight(requestParameters.height, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * HashLockRoutesApi - axios parameter creator
 * @export
 */
export const HashLockRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets the hash lock for a given hash.
         * @summary Get hash lock information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLock: async (hash, options = {}) => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getHashLock', 'hash', hash);
            const localVarPath = `/lock/hash/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the hash lock merkle for a given hash.
         * @summary Get hash lock merkle information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLockMerkle: async (hash, options = {}) => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getHashLockMerkle', 'hash', hash);
            const localVarPath = `/lock/hash/{hash}/merkle`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of hash locks.
         * @summary Search hash lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHashLock: async (address, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/lock/hash`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * HashLockRoutesApi - functional programming interface
 * @export
 */
export const HashLockRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = HashLockRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets the hash lock for a given hash.
         * @summary Get hash lock information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHashLock(hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHashLock(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the hash lock merkle for a given hash.
         * @summary Get hash lock merkle information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHashLockMerkle(hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHashLockMerkle(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of hash locks.
         * @summary Search hash lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchHashLock(address, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchHashLock(address, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * HashLockRoutesApi - factory interface
 * @export
 */
export const HashLockRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = HashLockRoutesApiFp(configuration);
    return {
        /**
         * Gets the hash lock for a given hash.
         * @summary Get hash lock information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLock(hash, options) {
            return localVarFp.getHashLock(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the hash lock merkle for a given hash.
         * @summary Get hash lock merkle information
         * @param {string} hash Filter by hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHashLockMerkle(hash, options) {
            return localVarFp.getHashLockMerkle(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of hash locks.
         * @summary Search hash lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchHashLock(address, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchHashLock(address, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * HashLockRoutesApi - object-oriented interface
 * @export
 * @class HashLockRoutesApi
 * @extends {BaseAPI}
 */
export class HashLockRoutesApi extends BaseAPI {
    /**
     * Gets the hash lock for a given hash.
     * @summary Get hash lock information
     * @param {HashLockRoutesApiGetHashLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashLockRoutesApi
     */
    getHashLock(requestParameters, options) {
        return HashLockRoutesApiFp(this.configuration).getHashLock(requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the hash lock merkle for a given hash.
     * @summary Get hash lock merkle information
     * @param {HashLockRoutesApiGetHashLockMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashLockRoutesApi
     */
    getHashLockMerkle(requestParameters, options) {
        return HashLockRoutesApiFp(this.configuration).getHashLockMerkle(requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of hash locks.
     * @summary Search hash lock entries
     * @param {HashLockRoutesApiSearchHashLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HashLockRoutesApi
     */
    searchHashLock(requestParameters = {}, options) {
        return HashLockRoutesApiFp(this.configuration).searchHashLock(requestParameters.address, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MetadataRoutesApi - axios parameter creator
 * @export
 */
export const MetadataRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets the metadata for a given composite hash.
         * @summary Get metadata information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata: async (compositeHash, options = {}) => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMetadata', 'compositeHash', compositeHash);
            const localVarPath = `/metadata/{compositeHash}`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the metadata merkle for a given composite hash.
         * @summary Get metadata merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataMerkle: async (compositeHash, options = {}) => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMetadataMerkle', 'compositeHash', compositeHash);
            const localVarPath = `/metadata/{compositeHash}/merkle`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of metadata.
         * @summary Search metadata entries
         * @param {string} [sourceAddress] Filter by address sending the metadata entry.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [scopedMetadataKey] Filter by metadata key.
         * @param {string} [targetId] Filter by namespace or mosaic id.
         * @param {MetadataTypeEnum} [metadataType] Filter by metadata type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMetadataEntries: async (sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (sourceAddress !== undefined) {
                localVarQueryParameter['sourceAddress'] = sourceAddress;
            }
            if (targetAddress !== undefined) {
                localVarQueryParameter['targetAddress'] = targetAddress;
            }
            if (scopedMetadataKey !== undefined) {
                localVarQueryParameter['scopedMetadataKey'] = scopedMetadataKey;
            }
            if (targetId !== undefined) {
                localVarQueryParameter['targetId'] = targetId;
            }
            if (metadataType !== undefined) {
                localVarQueryParameter['metadataType'] = metadataType;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MetadataRoutesApi - functional programming interface
 * @export
 */
export const MetadataRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MetadataRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets the metadata for a given composite hash.
         * @summary Get metadata information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadata(compositeHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadata(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the metadata merkle for a given composite hash.
         * @summary Get metadata merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMetadataMerkle(compositeHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMetadataMerkle(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of metadata.
         * @summary Search metadata entries
         * @param {string} [sourceAddress] Filter by address sending the metadata entry.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [scopedMetadataKey] Filter by metadata key.
         * @param {string} [targetId] Filter by namespace or mosaic id.
         * @param {MetadataTypeEnum} [metadataType] Filter by metadata type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MetadataRoutesApi - factory interface
 * @export
 */
export const MetadataRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MetadataRoutesApiFp(configuration);
    return {
        /**
         * Gets the metadata for a given composite hash.
         * @summary Get metadata information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadata(compositeHash, options) {
            return localVarFp.getMetadata(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the metadata merkle for a given composite hash.
         * @summary Get metadata merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMetadataMerkle(compositeHash, options) {
            return localVarFp.getMetadataMerkle(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of metadata.
         * @summary Search metadata entries
         * @param {string} [sourceAddress] Filter by address sending the metadata entry.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [scopedMetadataKey] Filter by metadata key.
         * @param {string} [targetId] Filter by namespace or mosaic id.
         * @param {MetadataTypeEnum} [metadataType] Filter by metadata type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchMetadataEntries(sourceAddress, targetAddress, scopedMetadataKey, targetId, metadataType, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MetadataRoutesApi - object-oriented interface
 * @export
 * @class MetadataRoutesApi
 * @extends {BaseAPI}
 */
export class MetadataRoutesApi extends BaseAPI {
    /**
     * Gets the metadata for a given composite hash.
     * @summary Get metadata information
     * @param {MetadataRoutesApiGetMetadataRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRoutesApi
     */
    getMetadata(requestParameters, options) {
        return MetadataRoutesApiFp(this.configuration).getMetadata(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the metadata merkle for a given composite hash.
     * @summary Get metadata merkle information
     * @param {MetadataRoutesApiGetMetadataMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRoutesApi
     */
    getMetadataMerkle(requestParameters, options) {
        return MetadataRoutesApiFp(this.configuration).getMetadataMerkle(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of metadata.
     * @summary Search metadata entries
     * @param {MetadataRoutesApiSearchMetadataEntriesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MetadataRoutesApi
     */
    searchMetadataEntries(requestParameters = {}, options) {
        return MetadataRoutesApiFp(this.configuration).searchMetadataEntries(requestParameters.sourceAddress, requestParameters.targetAddress, requestParameters.scopedMetadataKey, requestParameters.targetId, requestParameters.metadataType, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MosaicRoutesApi - axios parameter creator
 * @export
 */
export const MosaicRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets the mosaic definition for a given mosaic identifier.
         * @summary Get mosaic information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaic: async (mosaicId, options = {}) => {
            // verify required parameter 'mosaicId' is not null or undefined
            assertParamExists('getMosaic', 'mosaicId', mosaicId);
            const localVarPath = `/mosaics/{mosaicId}`
                .replace(`{${"mosaicId"}}`, encodeURIComponent(String(mosaicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the mosaic definition merkle for a given mosaic identifier.
         * @summary Get mosaic merkle information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicMerkle: async (mosaicId, options = {}) => {
            // verify required parameter 'mosaicId' is not null or undefined
            assertParamExists('getMosaicMerkle', 'mosaicId', mosaicId);
            const localVarPath = `/mosaics/{mosaicId}/merkle`
                .replace(`{${"mosaicId"}}`, encodeURIComponent(String(mosaicId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of mosaic definition.
         * @summary Get mosaics information for an array of mosaics
         * @param {MosaicIds} mosaicIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaics: async (mosaicIds, options = {}) => {
            // verify required parameter 'mosaicIds' is not null or undefined
            assertParamExists('getMosaics', 'mosaicIds', mosaicIds);
            const localVarPath = `/mosaics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mosaicIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of mosaics.
         * @summary Search mosaics
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaics: async (ownerAddress, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/mosaics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (ownerAddress !== undefined) {
                localVarQueryParameter['ownerAddress'] = ownerAddress;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MosaicRoutesApi - functional programming interface
 * @export
 */
export const MosaicRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MosaicRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets the mosaic definition for a given mosaic identifier.
         * @summary Get mosaic information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaic(mosaicId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaic(mosaicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the mosaic definition merkle for a given mosaic identifier.
         * @summary Get mosaic merkle information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicMerkle(mosaicId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicMerkle(mosaicId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of mosaic definition.
         * @summary Get mosaics information for an array of mosaics
         * @param {MosaicIds} mosaicIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaics(mosaicIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaics(mosaicIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of mosaics.
         * @summary Search mosaics
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMosaics(ownerAddress, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMosaics(ownerAddress, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MosaicRoutesApi - factory interface
 * @export
 */
export const MosaicRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MosaicRoutesApiFp(configuration);
    return {
        /**
         * Gets the mosaic definition for a given mosaic identifier.
         * @summary Get mosaic information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaic(mosaicId, options) {
            return localVarFp.getMosaic(mosaicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the mosaic definition merkle for a given mosaic identifier.
         * @summary Get mosaic merkle information
         * @param {string} mosaicId Mosaic identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicMerkle(mosaicId, options) {
            return localVarFp.getMosaicMerkle(mosaicId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of mosaic definition.
         * @summary Get mosaics information for an array of mosaics
         * @param {MosaicIds} mosaicIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaics(mosaicIds, options) {
            return localVarFp.getMosaics(mosaicIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of mosaics.
         * @summary Search mosaics
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaics(ownerAddress, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchMosaics(ownerAddress, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MosaicRoutesApi - object-oriented interface
 * @export
 * @class MosaicRoutesApi
 * @extends {BaseAPI}
 */
export class MosaicRoutesApi extends BaseAPI {
    /**
     * Gets the mosaic definition for a given mosaic identifier.
     * @summary Get mosaic information
     * @param {MosaicRoutesApiGetMosaicRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    getMosaic(requestParameters, options) {
        return MosaicRoutesApiFp(this.configuration).getMosaic(requestParameters.mosaicId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the mosaic definition merkle for a given mosaic identifier.
     * @summary Get mosaic merkle information
     * @param {MosaicRoutesApiGetMosaicMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    getMosaicMerkle(requestParameters, options) {
        return MosaicRoutesApiFp(this.configuration).getMosaicMerkle(requestParameters.mosaicId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of mosaic definition.
     * @summary Get mosaics information for an array of mosaics
     * @param {MosaicRoutesApiGetMosaicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    getMosaics(requestParameters, options) {
        return MosaicRoutesApiFp(this.configuration).getMosaics(requestParameters.mosaicIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of mosaics.
     * @summary Search mosaics
     * @param {MosaicRoutesApiSearchMosaicsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MosaicRoutesApi
     */
    searchMosaics(requestParameters = {}, options) {
        return MosaicRoutesApiFp(this.configuration).searchMosaics(requestParameters.ownerAddress, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * MultisigRoutesApi - axios parameter creator
 * @export
 */
export const MultisigRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the multisig account information.
         * @summary Get multisig account information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisig: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountMultisig', 'address', address);
            const localVarPath = `/account/{address}/multisig`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the multisig account graph.
         * @summary Get multisig account graph information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigGraph: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountMultisigGraph', 'address', address);
            const localVarPath = `/account/{address}/multisig/graph`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the multisig account merkle information.
         * @summary Get multisig account merkle information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigMerkle: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountMultisigMerkle', 'address', address);
            const localVarPath = `/account/{address}/multisig/merkle`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * MultisigRoutesApi - functional programming interface
 * @export
 */
export const MultisigRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = MultisigRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the multisig account information.
         * @summary Get multisig account information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountMultisig(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountMultisig(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the multisig account graph.
         * @summary Get multisig account graph information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountMultisigGraph(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountMultisigGraph(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the multisig account merkle information.
         * @summary Get multisig account merkle information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountMultisigMerkle(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountMultisigMerkle(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * MultisigRoutesApi - factory interface
 * @export
 */
export const MultisigRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = MultisigRoutesApiFp(configuration);
    return {
        /**
         * Returns the multisig account information.
         * @summary Get multisig account information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisig(address, options) {
            return localVarFp.getAccountMultisig(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the multisig account graph.
         * @summary Get multisig account graph information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigGraph(address, options) {
            return localVarFp.getAccountMultisigGraph(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the multisig account merkle information.
         * @summary Get multisig account merkle information
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountMultisigMerkle(address, options) {
            return localVarFp.getAccountMultisigMerkle(address, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * MultisigRoutesApi - object-oriented interface
 * @export
 * @class MultisigRoutesApi
 * @extends {BaseAPI}
 */
export class MultisigRoutesApi extends BaseAPI {
    /**
     * Returns the multisig account information.
     * @summary Get multisig account information
     * @param {MultisigRoutesApiGetAccountMultisigRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultisigRoutesApi
     */
    getAccountMultisig(requestParameters, options) {
        return MultisigRoutesApiFp(this.configuration).getAccountMultisig(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the multisig account graph.
     * @summary Get multisig account graph information
     * @param {MultisigRoutesApiGetAccountMultisigGraphRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultisigRoutesApi
     */
    getAccountMultisigGraph(requestParameters, options) {
        return MultisigRoutesApiFp(this.configuration).getAccountMultisigGraph(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the multisig account merkle information.
     * @summary Get multisig account merkle information
     * @param {MultisigRoutesApiGetAccountMultisigMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MultisigRoutesApi
     */
    getAccountMultisigMerkle(requestParameters, options) {
        return MultisigRoutesApiFp(this.configuration).getAccountMultisigMerkle(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NamespaceRoutesApi - axios parameter creator
 * @export
 */
export const NamespaceRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns friendly names for accounts.
         * @summary Get readable names for a set of accountIds
         * @param {Addresses} addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsNames: async (addresses, options = {}) => {
            // verify required parameter 'addresses' is not null or undefined
            assertParamExists('getAccountsNames', 'addresses', addresses);
            const localVarPath = `/namespaces/account/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(addresses, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns friendly names for mosaics.
         * @summary Get readable names for a set of mosaics
         * @param {MosaicIds} mosaicIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicsNames: async (mosaicIds, options = {}) => {
            // verify required parameter 'mosaicIds' is not null or undefined
            assertParamExists('getMosaicsNames', 'mosaicIds', mosaicIds);
            const localVarPath = `/namespaces/mosaic/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(mosaicIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the namespace for a given namespace identifier.
         * @summary Get namespace information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace: async (namespaceId, options = {}) => {
            // verify required parameter 'namespaceId' is not null or undefined
            assertParamExists('getNamespace', 'namespaceId', namespaceId);
            const localVarPath = `/namespaces/{namespaceId}`
                .replace(`{${"namespaceId"}}`, encodeURIComponent(String(namespaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the namespace merkle for a given namespace identifier.
         * @summary Get namespace merkle information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMerkle: async (namespaceId, options = {}) => {
            // verify required parameter 'namespaceId' is not null or undefined
            assertParamExists('getNamespaceMerkle', 'namespaceId', namespaceId);
            const localVarPath = `/namespaces/{namespaceId}/merkle`
                .replace(`{${"namespaceId"}}`, encodeURIComponent(String(namespaceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns friendly names for namespaces.
         * @summary Get readable names for a set of namespaces
         * @param {NamespaceIds} namespaceIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesNames: async (namespaceIds, options = {}) => {
            // verify required parameter 'namespaceIds' is not null or undefined
            assertParamExists('getNamespacesNames', 'namespaceIds', namespaceIds);
            const localVarPath = `/namespaces/names`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(namespaceIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of namespaces.
         * @summary Search namespaces
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {NamespaceRegistrationTypeEnum} [registrationType] Filter by registration type.
         * @param {string} [level0] Filter by root namespace.
         * @param {AliasTypeEnum} [aliasType] Filter by alias type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNamespaces: async (ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/namespaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (ownerAddress !== undefined) {
                localVarQueryParameter['ownerAddress'] = ownerAddress;
            }
            if (registrationType !== undefined) {
                localVarQueryParameter['registrationType'] = registrationType;
            }
            if (level0 !== undefined) {
                localVarQueryParameter['level0'] = level0;
            }
            if (aliasType !== undefined) {
                localVarQueryParameter['aliasType'] = aliasType;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NamespaceRoutesApi - functional programming interface
 * @export
 */
export const NamespaceRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = NamespaceRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns friendly names for accounts.
         * @summary Get readable names for a set of accountIds
         * @param {Addresses} addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountsNames(addresses, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountsNames(addresses, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns friendly names for mosaics.
         * @summary Get readable names for a set of mosaics
         * @param {MosaicIds} mosaicIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicsNames(mosaicIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicsNames(mosaicIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the namespace for a given namespace identifier.
         * @summary Get namespace information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespace(namespaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespace(namespaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the namespace merkle for a given namespace identifier.
         * @summary Get namespace merkle information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespaceMerkle(namespaceId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespaceMerkle(namespaceId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns friendly names for namespaces.
         * @summary Get readable names for a set of namespaces
         * @param {NamespaceIds} namespaceIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNamespacesNames(namespaceIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNamespacesNames(namespaceIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of namespaces.
         * @summary Search namespaces
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {NamespaceRegistrationTypeEnum} [registrationType] Filter by registration type.
         * @param {string} [level0] Filter by root namespace.
         * @param {AliasTypeEnum} [aliasType] Filter by alias type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NamespaceRoutesApi - factory interface
 * @export
 */
export const NamespaceRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NamespaceRoutesApiFp(configuration);
    return {
        /**
         * Returns friendly names for accounts.
         * @summary Get readable names for a set of accountIds
         * @param {Addresses} addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountsNames(addresses, options) {
            return localVarFp.getAccountsNames(addresses, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns friendly names for mosaics.
         * @summary Get readable names for a set of mosaics
         * @param {MosaicIds} mosaicIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicsNames(mosaicIds, options) {
            return localVarFp.getMosaicsNames(mosaicIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the namespace for a given namespace identifier.
         * @summary Get namespace information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespace(namespaceId, options) {
            return localVarFp.getNamespace(namespaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the namespace merkle for a given namespace identifier.
         * @summary Get namespace merkle information
         * @param {string} namespaceId Namespace identifier.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespaceMerkle(namespaceId, options) {
            return localVarFp.getNamespaceMerkle(namespaceId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns friendly names for namespaces.
         * @summary Get readable names for a set of namespaces
         * @param {NamespaceIds} namespaceIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNamespacesNames(namespaceIds, options) {
            return localVarFp.getNamespacesNames(namespaceIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of namespaces.
         * @summary Search namespaces
         * @param {string} [ownerAddress] Filter by owner address.
         * @param {NamespaceRegistrationTypeEnum} [registrationType] Filter by registration type.
         * @param {string} [level0] Filter by root namespace.
         * @param {AliasTypeEnum} [aliasType] Filter by alias type.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchNamespaces(ownerAddress, registrationType, level0, aliasType, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NamespaceRoutesApi - object-oriented interface
 * @export
 * @class NamespaceRoutesApi
 * @extends {BaseAPI}
 */
export class NamespaceRoutesApi extends BaseAPI {
    /**
     * Returns friendly names for accounts.
     * @summary Get readable names for a set of accountIds
     * @param {NamespaceRoutesApiGetAccountsNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    getAccountsNames(requestParameters, options) {
        return NamespaceRoutesApiFp(this.configuration).getAccountsNames(requestParameters.addresses, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns friendly names for mosaics.
     * @summary Get readable names for a set of mosaics
     * @param {NamespaceRoutesApiGetMosaicsNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    getMosaicsNames(requestParameters, options) {
        return NamespaceRoutesApiFp(this.configuration).getMosaicsNames(requestParameters.mosaicIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the namespace for a given namespace identifier.
     * @summary Get namespace information
     * @param {NamespaceRoutesApiGetNamespaceRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    getNamespace(requestParameters, options) {
        return NamespaceRoutesApiFp(this.configuration).getNamespace(requestParameters.namespaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the namespace merkle for a given namespace identifier.
     * @summary Get namespace merkle information
     * @param {NamespaceRoutesApiGetNamespaceMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    getNamespaceMerkle(requestParameters, options) {
        return NamespaceRoutesApiFp(this.configuration).getNamespaceMerkle(requestParameters.namespaceId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns friendly names for namespaces.
     * @summary Get readable names for a set of namespaces
     * @param {NamespaceRoutesApiGetNamespacesNamesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    getNamespacesNames(requestParameters, options) {
        return NamespaceRoutesApiFp(this.configuration).getNamespacesNames(requestParameters.namespaceIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of namespaces.
     * @summary Search namespaces
     * @param {NamespaceRoutesApiSearchNamespacesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NamespaceRoutesApi
     */
    searchNamespaces(requestParameters = {}, options) {
        return NamespaceRoutesApiFp(this.configuration).searchNamespaces(requestParameters.ownerAddress, requestParameters.registrationType, requestParameters.level0, requestParameters.aliasType, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NetworkRoutesApi - axios parameter creator
 * @export
 */
export const NetworkRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
         * @summary Get the network properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkProperties: async (options = {}) => {
            const localVarPath = `/network/properties`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current network type.
         * @summary Get the current network type of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkType: async (options = {}) => {
            const localVarPath = `/network`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
         * @summary Get rental fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRentalFees: async (options = {}) => {
            const localVarPath = `/network/fees/rental`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
         * @summary Get transaction fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFees: async (options = {}) => {
            const localVarPath = `/network/fees/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NetworkRoutesApi - functional programming interface
 * @export
 */
export const NetworkRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = NetworkRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
         * @summary Get the network properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkProperties(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkProperties(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the current network type.
         * @summary Get the current network type of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNetworkType(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNetworkType(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
         * @summary Get rental fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRentalFees(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRentalFees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
         * @summary Get transaction fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionFees(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionFees(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NetworkRoutesApi - factory interface
 * @export
 */
export const NetworkRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NetworkRoutesApiFp(configuration);
    return {
        /**
         * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
         * @summary Get the network properties
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkProperties(options) {
            return localVarFp.getNetworkProperties(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current network type.
         * @summary Get the current network type of the chain
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNetworkType(options) {
            return localVarFp.getNetworkType(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
         * @summary Get rental fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRentalFees(options) {
            return localVarFp.getRentalFees(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
         * @summary Get transaction fees information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionFees(options) {
            return localVarFp.getTransactionFees(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NetworkRoutesApi - object-oriented interface
 * @export
 * @class NetworkRoutesApi
 * @extends {BaseAPI}
 */
export class NetworkRoutesApi extends BaseAPI {
    /**
     * Returns the content from a catapult-server network configuration file (resources/config-network.properties). To enable this feature, the REST setting \"network.propertiesFilePath\" must define where the file is located. This is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * @summary Get the network properties
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    getNetworkProperties(options) {
        return NetworkRoutesApiFp(this.configuration).getNetworkProperties(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the current network type.
     * @summary Get the current network type of the chain
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    getNetworkType(options) {
        return NetworkRoutesApiFp(this.configuration).getNetworkType(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the estimated effective rental fees for namespaces and mosaics. This endpoint is only available if the REST instance has access to catapult-server ``resources/config-network.properties`` file. To activate this feature, add the setting \"network.propertiesFilePath\" in the configuration file (rest/resources/rest.json).
     * @summary Get rental fees information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    getRentalFees(options) {
        return NetworkRoutesApiFp(this.configuration).getRentalFees(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the average, median, highest and lower fee multiplier over the last \"numBlocksTransactionFeeStats\". The setting \"numBlocksTransactionFeeStats\" is adjustable via the configuration file (rest/resources/rest.json) per REST instance.
     * @summary Get transaction fees information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkRoutesApi
     */
    getTransactionFees(options) {
        return NetworkRoutesApiFp(this.configuration).getTransactionFees(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * NodeRoutesApi - axios parameter creator
 * @export
 */
export const NodeRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Supplies information regarding the connection and services status.
         * @summary Get the node health information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeHealth: async (options = {}) => {
            const localVarPath = `/node/health`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Supplies additional information about the application running on a node.
         * @summary Get the node information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo: async (options = {}) => {
            const localVarPath = `/node/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the list of peers visible by the node.
         * @summary Get peers information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodePeers: async (options = {}) => {
            const localVarPath = `/node/peers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns storage information about the node.
         * @summary Get the storage information of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeStorage: async (options = {}) => {
            const localVarPath = `/node/storage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the node time at the moment the reply was sent and received.
         * @summary Get the node time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeTime: async (options = {}) => {
            const localVarPath = `/node/time`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the version of the running catapult-rest component.
         * @summary Get the version of the running REST component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo: async (options = {}) => {
            const localVarPath = `/node/server`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns array of unlocked account public keys.
         * @summary Get the unlocked harvesting account public keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedAccount: async (options = {}) => {
            const localVarPath = `/node/unlockedaccount`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * NodeRoutesApi - functional programming interface
 * @export
 */
export const NodeRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = NodeRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Supplies information regarding the connection and services status.
         * @summary Get the node health information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeHealth(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeHealth(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Supplies additional information about the application running on a node.
         * @summary Get the node information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeInfo(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the list of peers visible by the node.
         * @summary Get peers information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodePeers(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodePeers(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns storage information about the node.
         * @summary Get the storage information of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeStorage(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeStorage(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the node time at the moment the reply was sent and received.
         * @summary Get the node time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNodeTime(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNodeTime(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the version of the running catapult-rest component.
         * @summary Get the version of the running REST component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getServerInfo(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getServerInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns array of unlocked account public keys.
         * @summary Get the unlocked harvesting account public keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnlockedAccount(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnlockedAccount(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * NodeRoutesApi - factory interface
 * @export
 */
export const NodeRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = NodeRoutesApiFp(configuration);
    return {
        /**
         * Supplies information regarding the connection and services status.
         * @summary Get the node health information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeHealth(options) {
            return localVarFp.getNodeHealth(options).then((request) => request(axios, basePath));
        },
        /**
         * Supplies additional information about the application running on a node.
         * @summary Get the node information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeInfo(options) {
            return localVarFp.getNodeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the list of peers visible by the node.
         * @summary Get peers information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodePeers(options) {
            return localVarFp.getNodePeers(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns storage information about the node.
         * @summary Get the storage information of the node
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeStorage(options) {
            return localVarFp.getNodeStorage(options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the node time at the moment the reply was sent and received.
         * @summary Get the node time
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNodeTime(options) {
            return localVarFp.getNodeTime(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the version of the running catapult-rest component.
         * @summary Get the version of the running REST component
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getServerInfo(options) {
            return localVarFp.getServerInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns array of unlocked account public keys.
         * @summary Get the unlocked harvesting account public keys.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnlockedAccount(options) {
            return localVarFp.getUnlockedAccount(options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * NodeRoutesApi - object-oriented interface
 * @export
 * @class NodeRoutesApi
 * @extends {BaseAPI}
 */
export class NodeRoutesApi extends BaseAPI {
    /**
     * Supplies information regarding the connection and services status.
     * @summary Get the node health information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getNodeHealth(options) {
        return NodeRoutesApiFp(this.configuration).getNodeHealth(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Supplies additional information about the application running on a node.
     * @summary Get the node information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getNodeInfo(options) {
        return NodeRoutesApiFp(this.configuration).getNodeInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the list of peers visible by the node.
     * @summary Get peers information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getNodePeers(options) {
        return NodeRoutesApiFp(this.configuration).getNodePeers(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns storage information about the node.
     * @summary Get the storage information of the node
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getNodeStorage(options) {
        return NodeRoutesApiFp(this.configuration).getNodeStorage(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the node time at the moment the reply was sent and received.
     * @summary Get the node time
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getNodeTime(options) {
        return NodeRoutesApiFp(this.configuration).getNodeTime(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the version of the running catapult-rest component.
     * @summary Get the version of the running REST component
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getServerInfo(options) {
        return NodeRoutesApiFp(this.configuration).getServerInfo(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns array of unlocked account public keys.
     * @summary Get the unlocked harvesting account public keys.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodeRoutesApi
     */
    getUnlockedAccount(options) {
        return NodeRoutesApiFp(this.configuration).getUnlockedAccount(options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * ReceiptRoutesApi - axios parameter creator
 * @export
 */
export const ReceiptRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets an array of address resolution statements.
         * @summary Get receipts address resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAddressResolutionStatements: async (height, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/statements/resolutions/address`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of mosaic resolution statements.
         * @summary Get receipts mosaic resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicResolutionStatements: async (height, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/statements/resolutions/mosaic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets an array of transaction statements.
         * @summary Search transaction statements
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {Array<ReceiptTypeEnum>} [receiptType] Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [senderAddress] Filter by address sending mosaics.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [artifactId] Mosaic or namespace identifier
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReceipts: async (height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/statements/transaction`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }
            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }
            if (receiptType) {
                localVarQueryParameter['receiptType'] = receiptType;
            }
            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }
            if (senderAddress !== undefined) {
                localVarQueryParameter['senderAddress'] = senderAddress;
            }
            if (targetAddress !== undefined) {
                localVarQueryParameter['targetAddress'] = targetAddress;
            }
            if (artifactId !== undefined) {
                localVarQueryParameter['artifactId'] = artifactId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * ReceiptRoutesApi - functional programming interface
 * @export
 */
export const ReceiptRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = ReceiptRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets an array of address resolution statements.
         * @summary Get receipts address resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of mosaic resolution statements.
         * @summary Get receipts mosaic resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets an array of transaction statements.
         * @summary Search transaction statements
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {Array<ReceiptTypeEnum>} [receiptType] Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [senderAddress] Filter by address sending mosaics.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [artifactId] Mosaic or namespace identifier
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchReceipts(height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchReceipts(height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * ReceiptRoutesApi - factory interface
 * @export
 */
export const ReceiptRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = ReceiptRoutesApiFp(configuration);
    return {
        /**
         * Gets an array of address resolution statements.
         * @summary Get receipts address resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchAddressResolutionStatements(height, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of mosaic resolution statements.
         * @summary Get receipts mosaic resolution statements
         * @param {string} [height] Filter by block height.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchMosaicResolutionStatements(height, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets an array of transaction statements.
         * @summary Search transaction statements
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {Array<ReceiptTypeEnum>} [receiptType] Filter by receipt type. To filter by multiple receipt types, add more filter query params like: &#x60;&#x60;receiptType&#x3D;8515&amp;receiptType&#x3D;20803&#x60;&#x60;.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [senderAddress] Filter by address sending mosaics.
         * @param {string} [targetAddress] Filter by target address.
         * @param {string} [artifactId] Mosaic or namespace identifier
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchReceipts(height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchReceipts(height, fromHeight, toHeight, receiptType, recipientAddress, senderAddress, targetAddress, artifactId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * ReceiptRoutesApi - object-oriented interface
 * @export
 * @class ReceiptRoutesApi
 * @extends {BaseAPI}
 */
export class ReceiptRoutesApi extends BaseAPI {
    /**
     * Gets an array of address resolution statements.
     * @summary Get receipts address resolution statements
     * @param {ReceiptRoutesApiSearchAddressResolutionStatementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptRoutesApi
     */
    searchAddressResolutionStatements(requestParameters = {}, options) {
        return ReceiptRoutesApiFp(this.configuration).searchAddressResolutionStatements(requestParameters.height, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of mosaic resolution statements.
     * @summary Get receipts mosaic resolution statements
     * @param {ReceiptRoutesApiSearchMosaicResolutionStatementsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptRoutesApi
     */
    searchMosaicResolutionStatements(requestParameters = {}, options) {
        return ReceiptRoutesApiFp(this.configuration).searchMosaicResolutionStatements(requestParameters.height, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets an array of transaction statements.
     * @summary Search transaction statements
     * @param {ReceiptRoutesApiSearchReceiptsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReceiptRoutesApi
     */
    searchReceipts(requestParameters = {}, options) {
        return ReceiptRoutesApiFp(this.configuration).searchReceipts(requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.receiptType, requestParameters.recipientAddress, requestParameters.senderAddress, requestParameters.targetAddress, requestParameters.artifactId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * RestrictionAccountRoutesApi - axios parameter creator
 * @export
 */
export const RestrictionAccountRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the account restrictions for a given address.
         * @summary Get the account restrictions
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictions: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountRestrictions', 'address', address);
            const localVarPath = `/restrictions/account/{address}`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the account restrictions merkle for a given address.
         * @summary Get the account restrictions merkle
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictionsMerkle: async (address, options = {}) => {
            // verify required parameter 'address' is not null or undefined
            assertParamExists('getAccountRestrictionsMerkle', 'address', address);
            const localVarPath = `/restrictions/account/{address}/merkle`
                .replace(`{${"address"}}`, encodeURIComponent(String(address)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of account restrictions.
         * @summary Search account restrictions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccountRestrictions: async (address, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/restrictions/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RestrictionAccountRoutesApi - functional programming interface
 * @export
 */
export const RestrictionAccountRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = RestrictionAccountRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the account restrictions for a given address.
         * @summary Get the account restrictions
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRestrictions(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRestrictions(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the account restrictions merkle for a given address.
         * @summary Get the account restrictions merkle
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountRestrictionsMerkle(address, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountRestrictionsMerkle(address, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of account restrictions.
         * @summary Search account restrictions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchAccountRestrictions(address, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchAccountRestrictions(address, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * RestrictionAccountRoutesApi - factory interface
 * @export
 */
export const RestrictionAccountRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RestrictionAccountRoutesApiFp(configuration);
    return {
        /**
         * Returns the account restrictions for a given address.
         * @summary Get the account restrictions
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictions(address, options) {
            return localVarFp.getAccountRestrictions(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the account restrictions merkle for a given address.
         * @summary Get the account restrictions merkle
         * @param {string} address Account address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountRestrictionsMerkle(address, options) {
            return localVarFp.getAccountRestrictionsMerkle(address, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of account restrictions.
         * @summary Search account restrictions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchAccountRestrictions(address, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchAccountRestrictions(address, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RestrictionAccountRoutesApi - object-oriented interface
 * @export
 * @class RestrictionAccountRoutesApi
 * @extends {BaseAPI}
 */
export class RestrictionAccountRoutesApi extends BaseAPI {
    /**
     * Returns the account restrictions for a given address.
     * @summary Get the account restrictions
     * @param {RestrictionAccountRoutesApiGetAccountRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionAccountRoutesApi
     */
    getAccountRestrictions(requestParameters, options) {
        return RestrictionAccountRoutesApiFp(this.configuration).getAccountRestrictions(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the account restrictions merkle for a given address.
     * @summary Get the account restrictions merkle
     * @param {RestrictionAccountRoutesApiGetAccountRestrictionsMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionAccountRoutesApi
     */
    getAccountRestrictionsMerkle(requestParameters, options) {
        return RestrictionAccountRoutesApiFp(this.configuration).getAccountRestrictionsMerkle(requestParameters.address, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of account restrictions.
     * @summary Search account restrictions
     * @param {RestrictionAccountRoutesApiSearchAccountRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionAccountRoutesApi
     */
    searchAccountRestrictions(requestParameters = {}, options) {
        return RestrictionAccountRoutesApiFp(this.configuration).searchAccountRestrictions(requestParameters.address, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * RestrictionMosaicRoutesApi - axios parameter creator
 * @export
 */
export const RestrictionMosaicRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the mosaic restrictions for a composite hash.
         * @summary Get the mosaic restrictions
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictions: async (compositeHash, options = {}) => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMosaicRestrictions', 'compositeHash', compositeHash);
            const localVarPath = `/restrictions/mosaic/{compositeHash}`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the mosaic restrictions merkle for a given composite hash.
         * @summary Get the mosaic restrictions merkle
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictionsMerkle: async (compositeHash, options = {}) => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getMosaicRestrictionsMerkle', 'compositeHash', compositeHash);
            const localVarPath = `/restrictions/mosaic/{compositeHash}/merkle`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of mosaic restrictions.
         * @summary Search mosaic restrictions
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {MosaicRestrictionEntryTypeEnum} [entryType] Filter by entry type.
         * @param {string} [targetAddress] Filter by target address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicRestrictions: async (mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/restrictions/mosaic`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (mosaicId !== undefined) {
                localVarQueryParameter['mosaicId'] = mosaicId;
            }
            if (entryType !== undefined) {
                localVarQueryParameter['entryType'] = entryType;
            }
            if (targetAddress !== undefined) {
                localVarQueryParameter['targetAddress'] = targetAddress;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * RestrictionMosaicRoutesApi - functional programming interface
 * @export
 */
export const RestrictionMosaicRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = RestrictionMosaicRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the mosaic restrictions for a composite hash.
         * @summary Get the mosaic restrictions
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicRestrictions(compositeHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicRestrictions(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the mosaic restrictions merkle for a given composite hash.
         * @summary Get the mosaic restrictions merkle
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMosaicRestrictionsMerkle(compositeHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMosaicRestrictionsMerkle(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of mosaic restrictions.
         * @summary Search mosaic restrictions
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {MosaicRestrictionEntryTypeEnum} [entryType] Filter by entry type.
         * @param {string} [targetAddress] Filter by target address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchMosaicRestrictions(mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchMosaicRestrictions(mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * RestrictionMosaicRoutesApi - factory interface
 * @export
 */
export const RestrictionMosaicRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = RestrictionMosaicRoutesApiFp(configuration);
    return {
        /**
         * Returns the mosaic restrictions for a composite hash.
         * @summary Get the mosaic restrictions
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictions(compositeHash, options) {
            return localVarFp.getMosaicRestrictions(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the mosaic restrictions merkle for a given composite hash.
         * @summary Get the mosaic restrictions merkle
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMosaicRestrictionsMerkle(compositeHash, options) {
            return localVarFp.getMosaicRestrictionsMerkle(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of mosaic restrictions.
         * @summary Search mosaic restrictions
         * @param {string} [mosaicId] Filter by mosaic identifier.
         * @param {MosaicRestrictionEntryTypeEnum} [entryType] Filter by entry type.
         * @param {string} [targetAddress] Filter by target address.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchMosaicRestrictions(mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchMosaicRestrictions(mosaicId, entryType, targetAddress, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * RestrictionMosaicRoutesApi - object-oriented interface
 * @export
 * @class RestrictionMosaicRoutesApi
 * @extends {BaseAPI}
 */
export class RestrictionMosaicRoutesApi extends BaseAPI {
    /**
     * Returns the mosaic restrictions for a composite hash.
     * @summary Get the mosaic restrictions
     * @param {RestrictionMosaicRoutesApiGetMosaicRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionMosaicRoutesApi
     */
    getMosaicRestrictions(requestParameters, options) {
        return RestrictionMosaicRoutesApiFp(this.configuration).getMosaicRestrictions(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns the mosaic restrictions merkle for a given composite hash.
     * @summary Get the mosaic restrictions merkle
     * @param {RestrictionMosaicRoutesApiGetMosaicRestrictionsMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionMosaicRoutesApi
     */
    getMosaicRestrictionsMerkle(requestParameters, options) {
        return RestrictionMosaicRoutesApiFp(this.configuration).getMosaicRestrictionsMerkle(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of mosaic restrictions.
     * @summary Search mosaic restrictions
     * @param {RestrictionMosaicRoutesApiSearchMosaicRestrictionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RestrictionMosaicRoutesApi
     */
    searchMosaicRestrictions(requestParameters = {}, options) {
        return RestrictionMosaicRoutesApiFp(this.configuration).searchMosaicRestrictions(requestParameters.mosaicId, requestParameters.entryType, requestParameters.targetAddress, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * SecretLockRoutesApi - axios parameter creator
 * @export
 */
export const SecretLockRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Gets the hash lock for a given composite hash.
         * @summary Get secret lock information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLock: async (compositeHash, options = {}) => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getSecretLock', 'compositeHash', compositeHash);
            const localVarPath = `/lock/secret/{compositeHash}`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Gets the hash lock merkle for a given composite hash.
         * @summary Get secret lock merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLockMerkle: async (compositeHash, options = {}) => {
            // verify required parameter 'compositeHash' is not null or undefined
            assertParamExists('getSecretLockMerkle', 'compositeHash', compositeHash);
            const localVarPath = `/lock/secret/{compositeHash}/merkle`
                .replace(`{${"compositeHash"}}`, encodeURIComponent(String(compositeHash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of secret locks.
         * @summary Search secret lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [secret] Filter by secret.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSecretLock: async (address, secret, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/lock/secret`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (secret !== undefined) {
                localVarQueryParameter['secret'] = secret;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * SecretLockRoutesApi - functional programming interface
 * @export
 */
export const SecretLockRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = SecretLockRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Gets the hash lock for a given composite hash.
         * @summary Get secret lock information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecretLock(compositeHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecretLock(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Gets the hash lock merkle for a given composite hash.
         * @summary Get secret lock merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSecretLockMerkle(compositeHash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSecretLockMerkle(compositeHash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of secret locks.
         * @summary Search secret lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [secret] Filter by secret.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchSecretLock(address, secret, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchSecretLock(address, secret, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * SecretLockRoutesApi - factory interface
 * @export
 */
export const SecretLockRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = SecretLockRoutesApiFp(configuration);
    return {
        /**
         * Gets the hash lock for a given composite hash.
         * @summary Get secret lock information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLock(compositeHash, options) {
            return localVarFp.getSecretLock(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Gets the hash lock merkle for a given composite hash.
         * @summary Get secret lock merkle information
         * @param {string} compositeHash Filter by composite hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSecretLockMerkle(compositeHash, options) {
            return localVarFp.getSecretLockMerkle(compositeHash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of secret locks.
         * @summary Search secret lock entries
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [secret] Filter by secret.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchSecretLock(address, secret, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchSecretLock(address, secret, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * SecretLockRoutesApi - object-oriented interface
 * @export
 * @class SecretLockRoutesApi
 * @extends {BaseAPI}
 */
export class SecretLockRoutesApi extends BaseAPI {
    /**
     * Gets the hash lock for a given composite hash.
     * @summary Get secret lock information
     * @param {SecretLockRoutesApiGetSecretLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretLockRoutesApi
     */
    getSecretLock(requestParameters, options) {
        return SecretLockRoutesApiFp(this.configuration).getSecretLock(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Gets the hash lock merkle for a given composite hash.
     * @summary Get secret lock merkle information
     * @param {SecretLockRoutesApiGetSecretLockMerkleRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretLockRoutesApi
     */
    getSecretLockMerkle(requestParameters, options) {
        return SecretLockRoutesApiFp(this.configuration).getSecretLockMerkle(requestParameters.compositeHash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of secret locks.
     * @summary Search secret lock entries
     * @param {SecretLockRoutesApiSearchSecretLockRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecretLockRoutesApi
     */
    searchSecretLock(requestParameters = {}, options) {
        return SecretLockRoutesApiFp(this.configuration).searchSecretLock(requestParameters.address, requestParameters.secret, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TransactionRoutesApi - axios parameter creator
 * @export
 */
export const TransactionRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Announces a cosignature transaction to the network.
         * @summary Announce a cosignature transaction
         * @param {Cosignature} cosignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceCosignatureTransaction: async (cosignature, options = {}) => {
            // verify required parameter 'cosignature' is not null or undefined
            assertParamExists('announceCosignatureTransaction', 'cosignature', cosignature);
            const localVarPath = `/transactions/cosignature`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(cosignature, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Announces an aggregate bonded transaction to the network.
         * @summary Announce an aggregate bonded transaction
         * @param {TransactionPayload} transactionPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcePartialTransaction: async (transactionPayload, options = {}) => {
            // verify required parameter 'transactionPayload' is not null or undefined
            assertParamExists('announcePartialTransaction', 'transactionPayload', transactionPayload);
            const localVarPath = `/transactions/partial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionPayload, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
         * @summary Announce a new transaction
         * @param {TransactionPayload} transactionPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceTransaction: async (transactionPayload, options = {}) => {
            // verify required parameter 'transactionPayload' is not null or undefined
            assertParamExists('announceTransaction', 'transactionPayload', transactionPayload);
            const localVarPath = `/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionPayload, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns confirmed transaction information given a transactionId or hash.
         * @summary Get confirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransaction: async (transactionId, options = {}) => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getConfirmedTransaction', 'transactionId', transactionId);
            const localVarPath = `/transactions/confirmed/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns confirmed transactions information for a given array of transactionIds.
         * @summary Get confirmed trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransactions: async (transactionIds, options = {}) => {
            // verify required parameter 'transactionIds' is not null or undefined
            assertParamExists('getConfirmedTransactions', 'transactionIds', transactionIds);
            const localVarPath = `/transactions/confirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns partial transaction information given a transactionId or hash.
         * @summary Get partial transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransaction: async (transactionId, options = {}) => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getPartialTransaction', 'transactionId', transactionId);
            const localVarPath = `/transactions/partial/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns partial transactions information for a given array of transactionIds.
         * @summary Get partial trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransactions: async (transactionIds, options = {}) => {
            // verify required parameter 'transactionIds' is not null or undefined
            assertParamExists('getPartialTransactions', 'transactionIds', transactionIds);
            const localVarPath = `/transactions/partial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns unconfirmed transaction information given a transactionId or hash.
         * @summary Get unconfirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransaction: async (transactionId, options = {}) => {
            // verify required parameter 'transactionId' is not null or undefined
            assertParamExists('getUnconfirmedTransaction', 'transactionId', transactionId);
            const localVarPath = `/transactions/unconfirmed/{transactionId}`
                .replace(`{${"transactionId"}}`, encodeURIComponent(String(transactionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns unconfirmed transactions information for a given array of transactionIds.
         * @summary Get unconfirmed trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransactions: async (transactionIds, options = {}) => {
            // verify required parameter 'transactionIds' is not null or undefined
            assertParamExists('getUnconfirmedTransactions', 'transactionIds', transactionIds);
            const localVarPath = `/transactions/unconfirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionIds, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time.
         * @summary Search confirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConfirmedTransactions: async (address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/transactions/confirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }
            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }
            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }
            if (fromTransferAmount !== undefined) {
                localVarQueryParameter['fromTransferAmount'] = fromTransferAmount;
            }
            if (toTransferAmount !== undefined) {
                localVarQueryParameter['toTransferAmount'] = toTransferAmount;
            }
            if (type) {
                localVarQueryParameter['type'] = type;
            }
            if (embedded !== undefined) {
                localVarQueryParameter['embedded'] = embedded;
            }
            if (transferMosaicId !== undefined) {
                localVarQueryParameter['transferMosaicId'] = transferMosaicId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of partial transactions.
         * @summary Search partial transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPartialTransactions: async (address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/transactions/partial`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }
            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }
            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }
            if (fromTransferAmount !== undefined) {
                localVarQueryParameter['fromTransferAmount'] = fromTransferAmount;
            }
            if (toTransferAmount !== undefined) {
                localVarQueryParameter['toTransferAmount'] = toTransferAmount;
            }
            if (type) {
                localVarQueryParameter['type'] = type;
            }
            if (embedded !== undefined) {
                localVarQueryParameter['embedded'] = embedded;
            }
            if (transferMosaicId !== undefined) {
                localVarQueryParameter['transferMosaicId'] = transferMosaicId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of unconfirmed transactions.
         * @summary Search unconfirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnconfirmedTransactions: async (address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options = {}) => {
            const localVarPath = `/transactions/unconfirmed`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (address !== undefined) {
                localVarQueryParameter['address'] = address;
            }
            if (recipientAddress !== undefined) {
                localVarQueryParameter['recipientAddress'] = recipientAddress;
            }
            if (signerPublicKey !== undefined) {
                localVarQueryParameter['signerPublicKey'] = signerPublicKey;
            }
            if (height !== undefined) {
                localVarQueryParameter['height'] = height;
            }
            if (fromHeight !== undefined) {
                localVarQueryParameter['fromHeight'] = fromHeight;
            }
            if (toHeight !== undefined) {
                localVarQueryParameter['toHeight'] = toHeight;
            }
            if (fromTransferAmount !== undefined) {
                localVarQueryParameter['fromTransferAmount'] = fromTransferAmount;
            }
            if (toTransferAmount !== undefined) {
                localVarQueryParameter['toTransferAmount'] = toTransferAmount;
            }
            if (type) {
                localVarQueryParameter['type'] = type;
            }
            if (embedded !== undefined) {
                localVarQueryParameter['embedded'] = embedded;
            }
            if (transferMosaicId !== undefined) {
                localVarQueryParameter['transferMosaicId'] = transferMosaicId;
            }
            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }
            if (pageNumber !== undefined) {
                localVarQueryParameter['pageNumber'] = pageNumber;
            }
            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }
            if (order !== undefined) {
                localVarQueryParameter['order'] = order;
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionRoutesApi - functional programming interface
 * @export
 */
export const TransactionRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Announces a cosignature transaction to the network.
         * @summary Announce a cosignature transaction
         * @param {Cosignature} cosignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announceCosignatureTransaction(cosignature, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announceCosignatureTransaction(cosignature, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Announces an aggregate bonded transaction to the network.
         * @summary Announce an aggregate bonded transaction
         * @param {TransactionPayload} transactionPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announcePartialTransaction(transactionPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announcePartialTransaction(transactionPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
         * @summary Announce a new transaction
         * @param {TransactionPayload} transactionPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async announceTransaction(transactionPayload, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.announceTransaction(transactionPayload, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns confirmed transaction information given a transactionId or hash.
         * @summary Get confirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfirmedTransaction(transactionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfirmedTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns confirmed transactions information for a given array of transactionIds.
         * @summary Get confirmed trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfirmedTransactions(transactionIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfirmedTransactions(transactionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns partial transaction information given a transactionId or hash.
         * @summary Get partial transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartialTransaction(transactionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartialTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns partial transactions information for a given array of transactionIds.
         * @summary Get partial trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPartialTransactions(transactionIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPartialTransactions(transactionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns unconfirmed transaction information given a transactionId or hash.
         * @summary Get unconfirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnconfirmedTransaction(transactionId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnconfirmedTransaction(transactionId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns unconfirmed transactions information for a given array of transactionIds.
         * @summary Get unconfirmed trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUnconfirmedTransactions(transactionIds, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUnconfirmedTransactions(transactionIds, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time.
         * @summary Search confirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of partial transactions.
         * @summary Search partial transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPartialTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPartialTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of unconfirmed transactions.
         * @summary Search unconfirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TransactionRoutesApi - factory interface
 * @export
 */
export const TransactionRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TransactionRoutesApiFp(configuration);
    return {
        /**
         * Announces a cosignature transaction to the network.
         * @summary Announce a cosignature transaction
         * @param {Cosignature} cosignature
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceCosignatureTransaction(cosignature, options) {
            return localVarFp.announceCosignatureTransaction(cosignature, options).then((request) => request(axios, basePath));
        },
        /**
         * Announces an aggregate bonded transaction to the network.
         * @summary Announce an aggregate bonded transaction
         * @param {TransactionPayload} transactionPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announcePartialTransaction(transactionPayload, options) {
            return localVarFp.announcePartialTransaction(transactionPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
         * @summary Announce a new transaction
         * @param {TransactionPayload} transactionPayload
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        announceTransaction(transactionPayload, options) {
            return localVarFp.announceTransaction(transactionPayload, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns confirmed transaction information given a transactionId or hash.
         * @summary Get confirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransaction(transactionId, options) {
            return localVarFp.getConfirmedTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns confirmed transactions information for a given array of transactionIds.
         * @summary Get confirmed trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfirmedTransactions(transactionIds, options) {
            return localVarFp.getConfirmedTransactions(transactionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns partial transaction information given a transactionId or hash.
         * @summary Get partial transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransaction(transactionId, options) {
            return localVarFp.getPartialTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns partial transactions information for a given array of transactionIds.
         * @summary Get partial trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartialTransactions(transactionIds, options) {
            return localVarFp.getPartialTransactions(transactionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns unconfirmed transaction information given a transactionId or hash.
         * @summary Get unconfirmed transaction information
         * @param {string} transactionId Transaction id or hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransaction(transactionId, options) {
            return localVarFp.getUnconfirmedTransaction(transactionId, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns unconfirmed transactions information for a given array of transactionIds.
         * @summary Get unconfirmed trasactions information
         * @param {TransactionIds} transactionIds
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnconfirmedTransactions(transactionIds, options) {
            return localVarFp.getUnconfirmedTransactions(transactionIds, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time.
         * @summary Search confirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchConfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of partial transactions.
         * @summary Search partial transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPartialTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchPartialTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of unconfirmed transactions.
         * @summary Search unconfirmed transactions
         * @param {string} [address] Filter by address involved in the transaction. An account\&#39;s address is considered to be involved in the transaction when the account is the sender, recipient, or it is required to cosign the transaction. This filter cannot be combined with &#x60;&#x60;recipientAddress&#x60;&#x60; and &#x60;&#x60;signerPublicKey&#x60;&#x60; query params.
         * @param {string} [recipientAddress] Filter by address of the account receiving the transaction.
         * @param {string} [signerPublicKey] Filter by public key of the account signing the entity.
         * @param {string} [height] Filter by block height.
         * @param {string} [fromHeight] Only blocks with height greater or equal than this one are returned.
         * @param {string} [toHeight] Only blocks with height smaller or equal than this one are returned.
         * @param {string} [fromTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, greater or equal than this amount are returned.
         * @param {string} [toTransferAmount] Requires providing the &#x60;transferMosaicId&#x60; filter. Only transfer transactions with a transfer amount of the provided mosaic id, lesser or equal than this amount are returned.
         * @param {Array<TransactionTypeEnum>} [type] Filter by transaction type. To filter by multiple transaction types, add more filter query params like: &#x60;&#x60;type&#x3D;16974&amp;type&#x3D;16718&#x60;&#x60;.
         * @param {boolean} [embedded] When true, the endpoint also returns all the embedded aggregate transactions. Otherwise, only top-level transactions used to calculate the block transactionsHash are returned. **Note:** This field does not work when combined with the &#x60;&#x60;address&#x60;&#x60; parameter. This is, embedded transactions containing the address specified through the &#x60;&#x60;address&#x60;&#x60; parameter will not be returned even when used with &#x60;&#x60;embedded&#x3D;true&#x60;&#x60;. There is no problem when using other parameters like &#x60;&#x60;recipientAddress&#x60;&#x60; instead.
         * @param {string} [transferMosaicId] Filters transactions involving a specific &#x60;&#x60;mosaicId&#x60;&#x60;.
         * @param {number} [pageSize] Select the number of entries to return.
         * @param {number} [pageNumber] Filter by page number.
         * @param {string} [offset] Entry id at which to start pagination. If the ordering parameter is set to -id, the elements returned precede the identifier. Otherwise, newer elements with respect to the id are returned.
         * @param {Order} [order] Sort responses in ascending or descending order based on the collection property set on the param &#x60;&#x60;orderBy&#x60;&#x60;. If the request does not specify &#x60;&#x60;orderBy&#x60;&#x60;, REST returns the collection ordered by id.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options) {
            return localVarFp.searchUnconfirmedTransactions(address, recipientAddress, signerPublicKey, height, fromHeight, toHeight, fromTransferAmount, toTransferAmount, type, embedded, transferMosaicId, pageSize, pageNumber, offset, order, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TransactionRoutesApi - object-oriented interface
 * @export
 * @class TransactionRoutesApi
 * @extends {BaseAPI}
 */
export class TransactionRoutesApi extends BaseAPI {
    /**
     * Announces a cosignature transaction to the network.
     * @summary Announce a cosignature transaction
     * @param {TransactionRoutesApiAnnounceCosignatureTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    announceCosignatureTransaction(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).announceCosignatureTransaction(requestParameters.cosignature, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Announces an aggregate bonded transaction to the network.
     * @summary Announce an aggregate bonded transaction
     * @param {TransactionRoutesApiAnnouncePartialTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    announcePartialTransaction(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).announcePartialTransaction(requestParameters.transactionPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Announces a transaction to the network. The [catbuffer library](https://github.com/nemtech/catbuffer) defines the protocol to serialize and deserialize Symbol entities. Catbuffers are integrated into [Symbol SDKs](https://nemtech.github.io/sdk.html).  It\'s recommended to use SDKs instead of calling the API endpoint directly to announce transactions.
     * @summary Announce a new transaction
     * @param {TransactionRoutesApiAnnounceTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    announceTransaction(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).announceTransaction(requestParameters.transactionPayload, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns confirmed transaction information given a transactionId or hash.
     * @summary Get confirmed transaction information
     * @param {TransactionRoutesApiGetConfirmedTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    getConfirmedTransaction(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).getConfirmedTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns confirmed transactions information for a given array of transactionIds.
     * @summary Get confirmed trasactions information
     * @param {TransactionRoutesApiGetConfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    getConfirmedTransactions(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).getConfirmedTransactions(requestParameters.transactionIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns partial transaction information given a transactionId or hash.
     * @summary Get partial transaction information
     * @param {TransactionRoutesApiGetPartialTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    getPartialTransaction(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).getPartialTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns partial transactions information for a given array of transactionIds.
     * @summary Get partial trasactions information
     * @param {TransactionRoutesApiGetPartialTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    getPartialTransactions(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).getPartialTransactions(requestParameters.transactionIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns unconfirmed transaction information given a transactionId or hash.
     * @summary Get unconfirmed transaction information
     * @param {TransactionRoutesApiGetUnconfirmedTransactionRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    getUnconfirmedTransaction(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).getUnconfirmedTransaction(requestParameters.transactionId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns unconfirmed transactions information for a given array of transactionIds.
     * @summary Get unconfirmed trasactions information
     * @param {TransactionRoutesApiGetUnconfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    getUnconfirmedTransactions(requestParameters, options) {
        return TransactionRoutesApiFp(this.configuration).getUnconfirmedTransactions(requestParameters.transactionIds, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of confirmed transactions. If a transaction was announced with an alias rather than an address, the address that will be considered when querying is the one that was resolved from the alias at confirmation time.
     * @summary Search confirmed transactions
     * @param {TransactionRoutesApiSearchConfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    searchConfirmedTransactions(requestParameters = {}, options) {
        return TransactionRoutesApiFp(this.configuration).searchConfirmedTransactions(requestParameters.address, requestParameters.recipientAddress, requestParameters.signerPublicKey, requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.fromTransferAmount, requestParameters.toTransferAmount, requestParameters.type, requestParameters.embedded, requestParameters.transferMosaicId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of partial transactions.
     * @summary Search partial transactions
     * @param {TransactionRoutesApiSearchPartialTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    searchPartialTransactions(requestParameters = {}, options) {
        return TransactionRoutesApiFp(this.configuration).searchPartialTransactions(requestParameters.address, requestParameters.recipientAddress, requestParameters.signerPublicKey, requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.fromTransferAmount, requestParameters.toTransferAmount, requestParameters.type, requestParameters.embedded, requestParameters.transferMosaicId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of unconfirmed transactions.
     * @summary Search unconfirmed transactions
     * @param {TransactionRoutesApiSearchUnconfirmedTransactionsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionRoutesApi
     */
    searchUnconfirmedTransactions(requestParameters = {}, options) {
        return TransactionRoutesApiFp(this.configuration).searchUnconfirmedTransactions(requestParameters.address, requestParameters.recipientAddress, requestParameters.signerPublicKey, requestParameters.height, requestParameters.fromHeight, requestParameters.toHeight, requestParameters.fromTransferAmount, requestParameters.toTransferAmount, requestParameters.type, requestParameters.embedded, requestParameters.transferMosaicId, requestParameters.pageSize, requestParameters.pageNumber, requestParameters.offset, requestParameters.order, options).then((request) => request(this.axios, this.basePath));
    }
}
/**
 * TransactionStatusRoutesApi - axios parameter creator
 * @export
 */
export const TransactionStatusRoutesApiAxiosParamCreator = function (configuration) {
    return {
        /**
         * Returns the transaction status for a given hash.
         * @summary Get transaction status
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatus: async (hash, options = {}) => {
            // verify required parameter 'hash' is not null or undefined
            assertParamExists('getTransactionStatus', 'hash', hash);
            const localVarPath = `/transactionStatus/{hash}`
                .replace(`{${"hash"}}`, encodeURIComponent(String(hash)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns an array of transaction statuses for a given array of transaction hashes.
         * @summary Get transaction statuses
         * @param {TransactionHashes} transactionHashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatuses: async (transactionHashes, options = {}) => {
            // verify required parameter 'transactionHashes' is not null or undefined
            assertParamExists('getTransactionStatuses', 'transactionHashes', transactionHashes);
            const localVarPath = `/transactionStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(transactionHashes, localVarRequestOptions, configuration);
            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
/**
 * TransactionStatusRoutesApi - functional programming interface
 * @export
 */
export const TransactionStatusRoutesApiFp = function (configuration) {
    const localVarAxiosParamCreator = TransactionStatusRoutesApiAxiosParamCreator(configuration);
    return {
        /**
         * Returns the transaction status for a given hash.
         * @summary Get transaction status
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionStatus(hash, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionStatus(hash, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns an array of transaction statuses for a given array of transaction hashes.
         * @summary Get transaction statuses
         * @param {TransactionHashes} transactionHashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTransactionStatuses(transactionHashes, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTransactionStatuses(transactionHashes, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};
/**
 * TransactionStatusRoutesApi - factory interface
 * @export
 */
export const TransactionStatusRoutesApiFactory = function (configuration, basePath, axios) {
    const localVarFp = TransactionStatusRoutesApiFp(configuration);
    return {
        /**
         * Returns the transaction status for a given hash.
         * @summary Get transaction status
         * @param {string} hash Transaction hash.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatus(hash, options) {
            return localVarFp.getTransactionStatus(hash, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns an array of transaction statuses for a given array of transaction hashes.
         * @summary Get transaction statuses
         * @param {TransactionHashes} transactionHashes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTransactionStatuses(transactionHashes, options) {
            return localVarFp.getTransactionStatuses(transactionHashes, options).then((request) => request(axios, basePath));
        },
    };
};
/**
 * TransactionStatusRoutesApi - object-oriented interface
 * @export
 * @class TransactionStatusRoutesApi
 * @extends {BaseAPI}
 */
export class TransactionStatusRoutesApi extends BaseAPI {
    /**
     * Returns the transaction status for a given hash.
     * @summary Get transaction status
     * @param {TransactionStatusRoutesApiGetTransactionStatusRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionStatusRoutesApi
     */
    getTransactionStatus(requestParameters, options) {
        return TransactionStatusRoutesApiFp(this.configuration).getTransactionStatus(requestParameters.hash, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns an array of transaction statuses for a given array of transaction hashes.
     * @summary Get transaction statuses
     * @param {TransactionStatusRoutesApiGetTransactionStatusesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TransactionStatusRoutesApi
     */
    getTransactionStatuses(requestParameters, options) {
        return TransactionStatusRoutesApiFp(this.configuration).getTransactionStatuses(requestParameters.transactionHashes, options).then((request) => request(this.axios, this.basePath));
    }
}
