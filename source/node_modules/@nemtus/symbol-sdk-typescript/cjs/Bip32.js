"use strict";
var PrivateKey = require('./CryptoTypes').PrivateKey;
var Mnemonic = require('bitcore-mnemonic');
var crypto = require('crypto');
/**
 * Representation of a BIP32 node.
 */
var Bip32Node = /** @class */ (function () {
    /**
     * Creates a BIP32 node around a key and data.
     * @param {string} hmacKey BIP32 HMAC key.
     * @param {Uint8Array} data BIP32 seed.
     */
    function Bip32Node(hmacKey, data) {
        var hmac = crypto.createHmac('sha512', hmacKey);
        hmac.update(data);
        var hmacResult = hmac.digest();
        this.privateKey = new PrivateKey(hmacResult.subarray(0, PrivateKey.SIZE));
        this.chainCode = hmacResult.subarray(PrivateKey.SIZE);
    }
    /**
     * Derives a direct child node with specified identifier.
     * @param {number} identifier Child identifier.
     * @returns {Bip32Node} BIP32 child node.
     */
    Bip32Node.prototype.deriveOne = function (identifier) {
        var childData = new Uint8Array(1 + PrivateKey.SIZE + 4);
        childData[0] = 0;
        childData[childData.length - 4] = 0x80;
        for (var i = 0; 4 > i; ++i)
            childData[childData.length - 1 - i] |= (identifier >> (8 * i)) & 0xFF;
        for (var i = 0; i < PrivateKey.SIZE; ++i)
            childData[1 + i] = this.privateKey.bytes[i];
        return new Bip32Node(this.chainCode, childData);
    };
    /**
     * Derives a descendent node with specified path.
     * @param {array<number>} path BIP32 path.
     * @returns {Bip32Node} BIP32 node at the end of the path.
     */
    Bip32Node.prototype.derivePath = function (path) {
        var nextNode = this;
        path.forEach(function (identifier) {
            nextNode = nextNode.deriveOne(identifier);
        });
        return nextNode;
    };
    return Bip32Node;
}());
/**
 * Factory of BIP32 root nodes.
 */
var Bip32 = /** @class */ (function () {
    /**
     * Creates a BIP32 root node factory.
     * @param {string} curveName Elliptic curve to use.
     * @param {string} mnemonicLanguage Language of constructed mnemonics.
     */
    function Bip32(curveName, mnemonicLanguage) {
        if (curveName === void 0) { curveName = 'ed25519'; }
        if (mnemonicLanguage === void 0) { mnemonicLanguage = 'english'; }
        this.rootHmacKey = Buffer.from("".concat(curveName, " seed"));
        this.mnemonicLanguage = mnemonicLanguage;
    }
    /**
     * Creates a BIP32 root node from a seed.
     * @param {Uint8Array} seed BIP32 seed.
     * @returns {Bip32Node} BIP32 root node.
     */
    Bip32.prototype.fromSeed = function (seed) {
        return new Bip32Node(this.rootHmacKey, seed);
    };
    /**
     * Creates a BIP32 root node from a BIP39 mnemonic and password.
     * @param {string} mnemonic BIP32 mnemonic.
     * @param {string} password BIP32 mnemonic password.
     * @returns {Bip32Node} BIP32 root node.
     */
    Bip32.prototype.fromMnemonic = function (mnemonic, password) {
        return this.fromSeed(new Mnemonic(mnemonic, this.mnemonic_language).toSeed(password));
    };
    return Bip32;
}());
module.exports = { Bip32: Bip32 };
