"use strict";
var BaseValue = require('./BaseValue').BaseValue;
var ByteArray = require('./ByteArray').ByteArray;
var TransactionDescriptorProcessor = require('./TransactionDescriptorProcessor').TransactionDescriptorProcessor;
var buildEnumStringToValueMap = function (EnumClass) { return new Map(Object.getOwnPropertyNames(EnumClass)
    .filter(function (name) { return name.toUpperCase() === name; })
    .map(function (name) { return [name.toLowerCase(), EnumClass[name]]; })); };
var nameToEnumValue = function (mapping, enumType, enumValueName) {
    if (!mapping.has(enumValueName))
        throw RangeError("unknown value ".concat(enumValueName, " for type ").concat(enumType));
    return mapping.get(enumValueName);
};
var buildTypeHintsMap = function (structValue) {
    var typeHints = {};
    var rawTypeHints = structValue.constructor.TYPE_HINTS || {};
    Object.getOwnPropertyNames(rawTypeHints).forEach(function (key) {
        var hint = rawTypeHints[key];
        var ruleName;
        if (0 === hint.indexOf('array['))
            ruleName = hint;
        else if (0 === hint.indexOf('enum:'))
            ruleName = hint.substring('enum:'.length);
        else if (0 === hint.indexOf('pod:'))
            ruleName = hint.substring('pod:'.length);
        else if (0 === hint.indexOf('struct:'))
            ruleName = hint;
        if (ruleName)
            typeHints[key] = ruleName;
    });
    return typeHints;
};
var typeConverterFactory = function (module, customTypeConverter, value) {
    if (customTypeConverter && customTypeConverter(value))
        return customTypeConverter(value);
    if (value instanceof ByteArray)
        return new module[value.constructor.name](value.bytes);
    return value;
};
var autoEncodeStrings = function (entity) {
    Object.getOwnPropertyNames(entity).forEach(function (key) {
        var value = entity[key];
        if ('string' === typeof (value))
            entity[key] = new TextEncoder().encode(value);
    });
};
/**
 * Rule based transaction factory.
 */
var RuleBasedTransactionFactory = /** @class */ (function () {
    /**
     * Creates a rule based transaction factory for use with catbuffer generated code.
     * @param {object} module Catbuffer generated module.
     * @param {function} typeConverter Type converter.
     * @param {Map} typeRuleOverrides Type rule overrides.
     */
    function RuleBasedTransactionFactory(module, typeConverter, typeRuleOverrides) {
        if (typeConverter === void 0) { typeConverter = undefined; }
        if (typeRuleOverrides === void 0) { typeRuleOverrides = undefined; }
        var _this = this;
        this.module = module;
        this.typeConverter = function (value) { return typeConverterFactory(_this.module, typeConverter, value); };
        this.typeRuleOverrides = typeRuleOverrides || new Map();
        this.rules = new Map();
    }
    RuleBasedTransactionFactory.prototype._getModuleClass = function (name) {
        return this.module[name];
    };
    /**
     * Creates wrapper for SDK POD types.
     * @param {string} name Class name.
     * @param {type} PodClass Class type.
     */
    RuleBasedTransactionFactory.prototype.addPodParser = function (name, PodClass) {
        if (this.typeRuleOverrides.has(PodClass)) {
            this.rules.set(name, this.typeRuleOverrides.get(PodClass));
            return;
        }
        this.rules.set(name, function (value) { return (value instanceof PodClass ? value : new PodClass(value)); });
    };
    /**
     * Creates flag type parser.
     * @param {string} name Class name.
     */
    RuleBasedTransactionFactory.prototype.addFlagsParser = function (name) {
        var FlagsClass = this._getModuleClass(name);
        var stringToEnum = buildEnumStringToValueMap(FlagsClass);
        this.rules.set(name, function (flags) {
            if ('string' === typeof (flags)) {
                var enumArray = flags.split(' ').map(function (flagName) { return nameToEnumValue(stringToEnum, name, flagName); });
                return new FlagsClass(enumArray.map(function (flag) { return flag.value; }).reduce(function (x, y) { return x | y; }));
            }
            if ('number' === typeof (flags) && Number.isInteger(flags))
                return new FlagsClass(flags);
            return flags;
        });
    };
    /**
     * Creates enum type parser.
     * @param {string} name Class name.
     */
    RuleBasedTransactionFactory.prototype.addEnumParser = function (name) {
        var EnumClass = this._getModuleClass(name);
        var stringToEnum = buildEnumStringToValueMap(EnumClass);
        this.rules.set(name, function (enumValue) {
            if ('string' === typeof (enumValue))
                return nameToEnumValue(stringToEnum, name, enumValue);
            if ('number' === typeof (enumValue) && Number.isInteger(enumValue))
                return new EnumClass(enumValue);
            return enumValue;
        });
    };
    /**
     * Creates struct parser (to allow nested parsing).
     * @param {string} name Class name.
     */
    RuleBasedTransactionFactory.prototype.addStructParser = function (name) {
        var _this = this;
        var StructClass = this._getModuleClass(name);
        this.rules.set("struct:".concat(name), function (structDescriptor) {
            var structProcessor = _this._createProcessor(structDescriptor);
            var structValue = new StructClass();
            var allTypeHints = buildTypeHintsMap(structValue);
            structProcessor.setTypeHints(allTypeHints);
            structProcessor.copyTo(structValue);
            return structValue;
        });
    };
    /**
     * Creates array type parser, based on some existing element type parser.
     * @param {string} name Class name.
     */
    RuleBasedTransactionFactory.prototype.addArrayParser = function (name) {
        var elementRule = this.rules.get(name);
        var elementName = name.replace(/^struct:/, '');
        this.rules.set("array[".concat(elementName, "]"), function (values) { return values.map(function (value) { return elementRule(value); }); });
    };
    /**
     * Autodetects rules using reflection.
     */
    RuleBasedTransactionFactory.prototype.autodetect = function () {
        var _this = this;
        Object.getOwnPropertyNames(this.module).forEach(function (key) {
            var cls = _this.module[key];
            if (Object.prototype.isPrototypeOf.call(BaseValue.prototype, cls.prototype))
                _this.addPodParser(key, cls);
        });
    };
    /**
     * Creates an entity from a descriptor using a factory.
     * @param {function} factory Factory function.
     * @param {object} descriptor Entity descriptor.
     * @returns {object} Newly created entity.
     */
    RuleBasedTransactionFactory.prototype.createFromFactory = function (factory, descriptor) {
        var processor = this._createProcessor(descriptor);
        var entityType = processor.lookupValue('type');
        var entity = factory(entityType);
        var allTypeHints = buildTypeHintsMap(entity);
        processor.setTypeHints(allTypeHints);
        processor.copyTo(entity, ['type']);
        autoEncodeStrings(entity);
        return entity;
    };
    RuleBasedTransactionFactory.prototype._createProcessor = function (descriptor) {
        return new TransactionDescriptorProcessor(descriptor, this.rules, this.typeConverter);
    };
    return RuleBasedTransactionFactory;
}());
module.exports = { RuleBasedTransactionFactory: RuleBasedTransactionFactory };
