"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a = require('../CryptoTypes'), Hash256 = _a.Hash256, PrivateKey = _a.PrivateKey;
var NetworkLocator = require('../Network').NetworkLocator;
var _b = require('../nem/KeyPair'), KeyPair = _b.KeyPair, Verifier = _b.Verifier;
var _c = require('../nem/Network'), Address = _c.Address, Network = _c.Network;
var TransactionFactory = require('../nem/TransactionFactory').TransactionFactory;
var keccak_256 = require('@noble/hashes/sha3').keccak_256;
/**
 * Facade used to interact with NEM blockchain.
 */
var NemFacade = /** @class */ (function () {
    /**
     * Creates a NEM facade.
     * @param {string|Network} network NEM network or network name.
     */
    function NemFacade(network) {
        this.network = 'string' === typeof network ? NetworkLocator.findByName(Network.NETWORKS, network) : network;
        this.transactionFactory = new TransactionFactory(this.network);
    }
    // the following three functions are NOT static in order for NemFacade and SymbolFacade to conform to the same interface
    /**
     * Hashes a NEM transaction.
     * @param {object} transaction Transaction object.
     * @returns {Hash256} Transaction hash.
     */
    NemFacade.prototype.hashTransaction = function (transaction) {
        var nonVerifiableTransaction = TransactionFactory.toNonVerifiableTransaction(transaction);
        return new Hash256(keccak_256(nonVerifiableTransaction.serialize()));
    };
    /**
     * Signs a NEM transaction.
     * @param {KeyPair} keyPair Key pair.
     * @param {object} transaction Transaction object.
     * @returns {Signature} Transaction signature.
     */
    NemFacade.prototype.signTransaction = function (keyPair, transaction) {
        var nonVerifiableTransaction = TransactionFactory.toNonVerifiableTransaction(transaction);
        return keyPair.sign(nonVerifiableTransaction.serialize());
    };
    /**
     * Verifies a NEM transaction.
     * @param {object} transaction Transaction object.
     * @param {Signature} signature Signature to verify.
     * @returns {boolean} true if transaction signature is verified.
     */
    NemFacade.prototype.verifyTransaction = function (transaction, signature) {
        var nonVerifiableTransaction = TransactionFactory.toNonVerifiableTransaction(transaction);
        return new Verifier(transaction.signerPublicKey).verify(nonVerifiableTransaction.serialize(), signature);
    };
    /**
     * Creates a network compatible BIP32 path for the specified account.
     *
     * @param {int} accountId Id of the account for which to generate a BIP32 path.
     * @returns {array<int>} BIP32 path for the specified account.
     */
    NemFacade.prototype.bip32Path = function (accountId) {
        return [44, 'mainnet' === this.network.name ? 43 : 1, accountId, 0, 0];
    };
    /**
     * Derives a NEM KeyPair from a BIP32 node.
     * @param {Bip32Node} bip32Node BIP32 node.
     * @returns {KeyPair} Derived key pair.
     */
    NemFacade.bip32NodeToKeyPair = function (bip32Node) {
        // BIP32 private keys should be used as is, so reverse here to counteract reverse in KeyPair
        var reversedPrivateKeyBytes = new Uint8Array(__spreadArray([], bip32Node.privateKey.bytes, true));
        reversedPrivateKeyBytes.reverse();
        return new KeyPair(new PrivateKey(reversedPrivateKeyBytes));
    };
    NemFacade.BIP32_CURVE_NAME = 'ed25519-keccak';
    NemFacade.Address = Address;
    NemFacade.KeyPair = KeyPair;
    NemFacade.Verifier = Verifier;
    return NemFacade;
}());
module.exports = { NemFacade: NemFacade };
