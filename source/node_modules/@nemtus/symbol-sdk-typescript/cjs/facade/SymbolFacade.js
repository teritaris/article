"use strict";
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var _a = require('../CryptoTypes'), Hash256 = _a.Hash256, PrivateKey = _a.PrivateKey, PublicKey = _a.PublicKey, Signature = _a.Signature;
var NetworkLocator = require('../Network').NetworkLocator;
var _b = require('../symbol/KeyPair'), KeyPair = _b.KeyPair, Verifier = _b.Verifier;
var MerkleHashBuilder = require('../symbol/MerkleHashBuilder').MerkleHashBuilder;
var _c = require('../symbol/Network'), Address = _c.Address, Network = _c.Network;
var TransactionFactory = require('../symbol/TransactionFactory').TransactionFactory;
var TransactionType = require('../symbol/models').TransactionType;
var sha3_256 = require('@noble/hashes/sha3').sha3_256;
var TRANSACTION_HEADER_SIZE = [
    4,
    4,
    Signature.SIZE,
    PublicKey.SIZE,
    4 // reserved2
].reduce(function (x, y) { return x + y; });
var AGGREGATE_HASHED_SIZE = [
    4,
    8,
    8,
    Hash256.SIZE // transactionsHash
].reduce(function (x, y) { return x + y; });
var isAggregateTransaction = function (transactionBuffer) {
    var transactionTypeOffset = TRANSACTION_HEADER_SIZE + 2; // skip version and network byte
    var transactionType = (transactionBuffer[transactionTypeOffset + 1] << 8) + transactionBuffer[transactionTypeOffset];
    var aggregateTypes = [TransactionType.AGGREGATE_BONDED.value, TransactionType.AGGREGATE_COMPLETE.value];
    return aggregateTypes.some(function (aggregateType) { return aggregateType === transactionType; });
};
var transactionDataBuffer = function (transactionBuffer) {
    var dataBufferStart = TRANSACTION_HEADER_SIZE;
    var dataBufferEnd = isAggregateTransaction(transactionBuffer)
        ? TRANSACTION_HEADER_SIZE + AGGREGATE_HASHED_SIZE
        : transactionBuffer.length;
    return transactionBuffer.subarray(dataBufferStart, dataBufferEnd);
};
/**
 * Facade used to interact with Symbol blockchain.
 */
var SymbolFacade = /** @class */ (function () {
    /**
     * Creates a Symbol facade.
     * @param {string|Network} network Symbol network or network name.
     */
    function SymbolFacade(network) {
        this.network = 'string' === typeof network ? NetworkLocator.findByName(Network.NETWORKS, network) : network;
        this.transactionFactory = new TransactionFactory(this.network);
    }
    /**
     * Hashes a Symbol transaction.
     * @param {object} transaction Transaction object.
     * @returns {Hash256} Transaction hash.
     */
    SymbolFacade.prototype.hashTransaction = function (transaction) {
        var hasher = sha3_256.create();
        hasher.update(transaction.signature.bytes);
        hasher.update(transaction.signerPublicKey.bytes);
        hasher.update(this.network.generationHashSeed.bytes);
        hasher.update(transactionDataBuffer(transaction.serialize()));
        return new Hash256(hasher.digest());
    };
    /**
     * Signs a Symbol transaction.
     * @param {KeyPair} keyPair Key pair.
     * @param {object} transaction Transaction object.
     * @returns {Signature} Transaction signature.
     */
    SymbolFacade.prototype.signTransaction = function (keyPair, transaction) {
        return keyPair.sign(new Uint8Array(__spreadArray(__spreadArray([], this.network.generationHashSeed.bytes, true), transactionDataBuffer(transaction.serialize()), true)));
    };
    /**
     * Verifies a Symbol transaction.
     * @param {object} transaction Transaction object.
     * @param {Signature} signature Signature to verify.
     * @returns {boolean} true if transaction signature is verified.
     */
    SymbolFacade.prototype.verifyTransaction = function (transaction, signature) {
        var verifyBuffer = new Uint8Array(__spreadArray(__spreadArray([], this.network.generationHashSeed.bytes, true), transactionDataBuffer(transaction.serialize()), true));
        return new Verifier(transaction.signerPublicKey).verify(verifyBuffer, signature);
    };
    /**
     * Hashes embedded transactions of an aggregate."""
     * @param {array<object>} embeddedTransactions Embedded transactions to hash.
     * @returns {Hash256} Aggregate transactions hash.
     */
    SymbolFacade.hashEmbeddedTransactions = function (embeddedTransactions) {
        var hashBuilder = new MerkleHashBuilder();
        embeddedTransactions.forEach(function (embeddedTransaction) {
            hashBuilder.update(new Hash256(sha3_256(embeddedTransaction.serialize())));
        });
        return hashBuilder.final();
    };
    /**
     * Creates a network compatible BIP32 path for the specified account.
     *
     * @param {int} accountId Id of the account for which to generate a BIP32 path.
     * @returns {array<int>} BIP32 path for the specified account.
     */
    SymbolFacade.prototype.bip32Path = function (accountId) {
        return [44, 'mainnet' === this.network.name ? 4343 : 1, accountId, 0, 0];
    };
    /**
     * Derives a Symbol KeyPair from a BIP32 node.
     * @param {Bip32Node} bip32Node BIP32 node.
     * @returns {KeyPair} Derived key pair.
     */
    SymbolFacade.bip32NodeToKeyPair = function (bip32Node) {
        return new KeyPair(new PrivateKey(bip32Node.privateKey.bytes));
    };
    SymbolFacade.BIP32_CURVE_NAME = 'ed25519';
    SymbolFacade.Address = Address;
    SymbolFacade.KeyPair = KeyPair;
    SymbolFacade.Verifier = Verifier;
    return SymbolFacade;
}());
module.exports = { SymbolFacade: SymbolFacade };
