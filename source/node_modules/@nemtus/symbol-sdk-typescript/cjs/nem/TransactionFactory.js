"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Address = require('./Network').Address;
var nc = require('./models');
var _a = require('../CryptoTypes'), Hash256 = _a.Hash256, PublicKey = _a.PublicKey;
var RuleBasedTransactionFactory = require('../RuleBasedTransactionFactory').RuleBasedTransactionFactory;
var uint8ToHex = require('../utils/converter').uint8ToHex;
/**
 * Factory for creating NEM transactions.
 */
var TransactionFactory = /** @class */ (function () {
    /**
     * Creates a factory for the specified network.
     * @param {Network} network NEM network.
     * @param {Map} typeRuleOverrides Type rule overrides.
     */
    function TransactionFactory(network, typeRuleOverrides) {
        this.factory = TransactionFactory.buildRules(typeRuleOverrides);
        this.network = network;
    }
    /**
     * Creates a transaction from a transaction descriptor.
     * @param {object} transactionDescriptor Transaction descriptor.
     * @returns {object} Newly created transaction.
     */
    TransactionFactory.prototype.create = function (transactionDescriptor) {
        var transaction = this.factory.createFromFactory(nc.TransactionFactory.createByName, __assign(__assign({}, transactionDescriptor), { network: this.network.identifier }));
        // hack: explicitly translate transfer message
        if (nc.TransactionType.TRANSFER === transaction.type && 'string' === typeof (transaction.message.message))
            transaction.message.message = new TextEncoder().encode(transaction.message.message);
        return transaction;
    };
    /**
     * Converts a transaction to a non-verifiable transaction.
     * @param {object} transaction Transaction object.
     * @returns {object} Non-verifiable transaction object.
     */
    TransactionFactory.toNonVerifiableTransaction = function (transaction) {
        var nonVerifiableClassName = transaction.constructor.name;
        if (0 !== nonVerifiableClassName.indexOf('NonVerifiable'))
            nonVerifiableClassName = "NonVerifiable".concat(nonVerifiableClassName);
        var NonVerifiableClass = nc[nonVerifiableClassName];
        var nonVerifiableTransaction = new NonVerifiableClass();
        Object.getOwnPropertyNames(transaction).forEach(function (key) {
            nonVerifiableTransaction[key] = transaction[key];
        });
        return nonVerifiableTransaction;
    };
    /**
     * Attaches a signature to a transaction.
     * @param {object} transaction Transaction object.
     * @param {Signature} signature Signature to attach.
     * @returns {string} JSON transaction payload.
     */
    TransactionFactory.attachSignature = function (transaction, signature) {
        transaction.signature = new nc.Signature(signature.bytes);
        var transactionHex = uint8ToHex(this.toNonVerifiableTransaction(transaction).serialize());
        var signatureHex = signature.toString();
        var jsonPayload = "{\"data\":\"".concat(transactionHex, "\", \"signature\":\"").concat(signatureHex, "\"}");
        return jsonPayload;
    };
    TransactionFactory._nemTypeConverter = function (value) {
        if (value instanceof Address) {
            // yes, unfortunately, nem's Address is 40 bytes string, but we need to pass it as actual bytes not to confuse ByteArray
            return new nc.Address(new TextEncoder().encode(value.toString()));
        }
        return undefined;
    };
    TransactionFactory.buildRules = function (typeRuleOverrides) {
        var factory = new RuleBasedTransactionFactory(nc, this._nemTypeConverter, typeRuleOverrides);
        factory.autodetect();
        [
            'LinkAction', 'MessageType', 'MosaicSupplyChangeAction', 'MosaicTransferFeeType',
            'MultisigAccountModificationType', 'NetworkType', 'TransactionType'
        ].forEach(function (name) { factory.addEnumParser(name); });
        [
            'Message', 'NamespaceId', 'MosaicId', 'Mosaic', 'SizePrefixedMosaic', 'MosaicLevy',
            'MosaicProperty', 'SizePrefixedMosaicProperty', 'MosaicDefinition',
            'MultisigAccountModification', 'SizePrefixedMultisigAccountModification'
        ].forEach(function (name) { factory.addStructParser(name); });
        var sdkTypeMapping = {
            Address: Address,
            Hash256: Hash256,
            PublicKey: PublicKey
        };
        Object.keys(sdkTypeMapping).forEach(function (name) { factory.addPodParser(name, sdkTypeMapping[name]); });
        [
            'struct:SizePrefixedMosaic', 'struct:SizePrefixedMosaicProperty', 'struct:SizePrefixedMultisigAccountModification'
        ].forEach(function (name) { factory.addArrayParser(name); });
        return factory;
    };
    return TransactionFactory;
}());
module.exports = { TransactionFactory: TransactionFactory };
