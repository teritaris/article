"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Address = require('./Network').Address;
var _a = require('./idGenerator'), generateNamespaceId = _a.generateNamespaceId, generateMosaicId = _a.generateMosaicId;
var sc = require('./models');
var _b = require('../CryptoTypes'), Hash256 = _b.Hash256, PublicKey = _b.PublicKey;
var RuleBasedTransactionFactory = require('../RuleBasedTransactionFactory').RuleBasedTransactionFactory;
var uint8ToHex = require('../utils/converter').uint8ToHex;
/**
 * Factory for creating Symbol transactions.
 */
var TransactionFactory = /** @class */ (function () {
    /**
     * Creates a factory for the specified network.
     * @param {Network} network Symbol network.
     * @param {Map} typeRuleOverrides Type rule overrides.
     */
    function TransactionFactory(network, typeRuleOverrides) {
        this.factory = TransactionFactory.buildRules(typeRuleOverrides);
        this.network = network;
    }
    TransactionFactory.prototype._createAndExtend = function (transactionDescriptor, FactoryClass) {
        var transaction = this.factory.createFromFactory(FactoryClass.createByName, __assign(__assign({}, transactionDescriptor), { network: this.network.identifier }));
        // autogenerate artifact ids
        if (sc.TransactionType.NAMESPACE_REGISTRATION === transaction.type) {
            var rawNamespaceId = generateNamespaceId(new TextDecoder().decode(transaction.name), transaction.parentId.value);
            transaction.id = new sc.NamespaceId(rawNamespaceId);
        }
        else if (sc.TransactionType.MOSAIC_DEFINITION === transaction.type) {
            var address = this.network.publicKeyToAddress(new PublicKey(transaction.signerPublicKey.bytes));
            transaction.id = new sc.MosaicId(generateMosaicId(address, transaction.nonce.value));
        }
        return transaction;
    };
    /**
     * Creates a transaction from a transaction descriptor.
     * @param {object} transactionDescriptor Transaction descriptor.
     * @returns {object} Newly created transaction.
     */
    TransactionFactory.prototype.create = function (transactionDescriptor) {
        return this._createAndExtend(transactionDescriptor, sc.TransactionFactory);
    };
    /**
     * Creates an embedded transaction from a transaction descriptor.
     * @param {object} transactionDescriptor Transaction descriptor.
     * @returns {object} Newly created transaction.
     */
    TransactionFactory.prototype.createEmbedded = function (transactionDescriptor) {
        return this._createAndExtend(transactionDescriptor, sc.EmbeddedTransactionFactory);
    };
    /**
     * Attaches a signature to a transaction.
     * @param {object} transaction Transaction object.
     * @param {Signature} signature Signature to attach.
     * @returns {string} JSON transaction payload.
     */
    TransactionFactory.attachSignature = function (transaction, signature) {
        transaction.signature = new sc.Signature(signature.bytes);
        var transactionBuffer = transaction.serialize();
        var hexPayload = uint8ToHex(transactionBuffer);
        var jsonPayload = "{\"payload\": \"".concat(hexPayload, "\"}");
        return jsonPayload;
    };
    TransactionFactory._symbolTypeConverter = function (value) {
        if (value instanceof Address)
            return new sc.UnresolvedAddress(value.bytes);
        return undefined;
    };
    TransactionFactory.buildRules = function (typeRuleOverrides) {
        var factory = new RuleBasedTransactionFactory(sc, this._symbolTypeConverter, typeRuleOverrides);
        factory.autodetect();
        ['MosaicFlags', 'AccountRestrictionFlags'].forEach(function (name) { factory.addFlagsParser(name); });
        [
            'AliasAction', 'LinkAction', 'LockHashAlgorithm',
            'MosaicRestrictionType', 'MosaicSupplyChangeAction',
            'NamespaceRegistrationType', 'NetworkType', 'TransactionType'
        ].forEach(function (name) { factory.addEnumParser(name); });
        factory.addStructParser('UnresolvedMosaic');
        var sdkTypeMapping = {
            UnresolvedAddress: Address,
            Address: Address,
            Hash256: Hash256,
            PublicKey: PublicKey,
            VotingPublicKey: PublicKey
        };
        Object.keys(sdkTypeMapping).forEach(function (name) { factory.addPodParser(name, sdkTypeMapping[name]); });
        ['UnresolvedMosaicId', 'TransactionType', 'UnresolvedAddress', 'struct:UnresolvedMosaic'].forEach(function (name) {
            factory.addArrayParser(name);
        });
        return factory;
    };
    return TransactionFactory;
}());
module.exports = { TransactionFactory: TransactionFactory };
