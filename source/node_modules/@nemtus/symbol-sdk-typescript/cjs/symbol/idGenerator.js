"use strict";
var sha3_256 = require('@noble/hashes/sha3').sha3_256;
var NAMESPACE_FLAG = 1n << 63n;
var uint32ToBytes = function (value) { return new Uint8Array([
    value & 0xFF,
    (value >> 8) & 0xFF,
    (value >> 16) & 0xFF,
    (value >> 24) & 0xFF
]); };
var digestToBigInt = function (digest) {
    var result = 0n;
    for (var i = 0; 8 > i; ++i)
        result += (BigInt(digest[i]) << BigInt(8 * i));
    return result;
};
/**
 * Generates a mosaic id from an owner address and a nonce.
 * @param {Address} ownerAddress Owner address.
 * @param {number} nonce Nonce.
 * @returns {BigInt} Computed mosaic id.
 */
var generateMosaicId = function (ownerAddress, nonce) {
    var hasher = sha3_256.create();
    hasher.update(uint32ToBytes(nonce));
    hasher.update(ownerAddress.bytes);
    var digest = hasher.digest();
    var result = digestToBigInt(digest);
    if (result & NAMESPACE_FLAG)
        result -= NAMESPACE_FLAG;
    return result;
};
/**
 * Generates a namespace id from a name and an optional parent namespace id.
 * @param {string} name Namespace name.
 * @param {BigInt} parentNamespaceId Parent namespace id.
 * @returns {BigInt} Computed namespace id.
 */
var generateNamespaceId = function (name, parentNamespaceId) {
    if (parentNamespaceId === void 0) { parentNamespaceId = 0n; }
    var hasher = sha3_256.create();
    hasher.update(uint32ToBytes(Number(parentNamespaceId & 0xffffffffn)));
    hasher.update(uint32ToBytes(Number((parentNamespaceId >> 32n) & 0xffffffffn)));
    hasher.update(name);
    var digest = new Uint8Array(hasher.digest());
    var result = digestToBigInt(digest);
    return result | NAMESPACE_FLAG;
};
/**
 * Returns true if a name is a valid namespace name.
 * @param {string} name Namespace name to check.
 * @returns {boolean} true if the specified name is valid.
 */
var isValidNamespaceName = function (name) {
    var isAlphanum = function (character) { return ('a' <= character && 'z' >= character) || ('0' <= character && '9' >= character); };
    if (!name || !isAlphanum(name[0]))
        return false;
    for (var i = 0; i < name.length; ++i) {
        var ch = name[i];
        if (!isAlphanum(ch) && '_' !== ch && '-' !== ch)
            return false;
    }
    return true;
};
/**
 * Parses a fully qualified namespace name into a path.
 * @param {string} fullyQualifiedName Fully qualified namespace name.
 * @returns {array<BigInt>} Computed namespace path.
 */
var generateNamespacePath = function (fullyQualifiedName) {
    var path = [];
    var parentNamespaceId = 0n;
    fullyQualifiedName.split('.').forEach(function (name) {
        if (!isValidNamespaceName(name))
            throw Error("fully qualified name is invalid due to invalid part name (".concat(fullyQualifiedName, ")"));
        path.push(generateNamespaceId(name, parentNamespaceId));
        parentNamespaceId = path[path.length - 1];
    });
    return path;
};
/**
 * Generates a mosaic id from a fully qualified mosaic alias name.
 * @param {string} fullyQualifiedName Fully qualified mosaic name.
 * @returns {BigInt} Computed mosaic id.
 */
var generateMosaicAliasId = function (fullyQualifiedName) {
    var path = generateNamespacePath(fullyQualifiedName);
    return path[path.length - 1];
};
module.exports = {
    generateMosaicId: generateMosaicId,
    generateNamespaceId: generateNamespaceId,
    isValidNamespaceName: isValidNamespaceName,
    generateNamespacePath: generateNamespacePath,
    generateMosaicAliasId: generateMosaicAliasId
};
