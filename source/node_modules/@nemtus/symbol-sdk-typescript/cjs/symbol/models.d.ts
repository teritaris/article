export class Amount extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): Amount;
    constructor(amount?: bigint);
    serialize(): Uint8Array;
}
export class BlockDuration extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): BlockDuration;
    constructor(blockDuration?: bigint);
    serialize(): Uint8Array;
}
export class BlockFeeMultiplier extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): BlockFeeMultiplier;
    constructor(blockFeeMultiplier?: number);
    serialize(): Uint8Array;
}
export class Difficulty extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): Difficulty;
    constructor(difficulty?: bigint);
    serialize(): Uint8Array;
}
export class FinalizationEpoch extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): FinalizationEpoch;
    constructor(finalizationEpoch?: number);
    serialize(): Uint8Array;
}
export class FinalizationPoint extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): FinalizationPoint;
    constructor(finalizationPoint?: number);
    serialize(): Uint8Array;
}
export class Height extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): Height;
    constructor(height?: bigint);
    serialize(): Uint8Array;
}
export class Importance extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): Importance;
    constructor(importance?: bigint);
    serialize(): Uint8Array;
}
export class ImportanceHeight extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): ImportanceHeight;
    constructor(importanceHeight?: bigint);
    serialize(): Uint8Array;
}
export class UnresolvedMosaicId extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): UnresolvedMosaicId;
    constructor(unresolvedMosaicId?: bigint);
    serialize(): Uint8Array;
}
export class MosaicId extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): MosaicId;
    constructor(mosaicId?: bigint);
    serialize(): Uint8Array;
}
export class Timestamp extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): Timestamp;
    constructor(timestamp?: bigint);
    serialize(): Uint8Array;
}
export class UnresolvedAddress extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): UnresolvedAddress;
    constructor(unresolvedAddress?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class Address extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): Address;
    constructor(address?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class Hash256 extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): Hash256;
    constructor(hash256?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class Hash512 extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): Hash512;
    constructor(hash512?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class PublicKey extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): PublicKey;
    constructor(publicKey?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class VotingPublicKey extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): VotingPublicKey;
    constructor(votingPublicKey?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class Signature extends ByteArray {
    static SIZE: number;
    static deserialize(payload: any): Signature;
    constructor(signature?: Uint8Array);
    get size(): number;
    serialize(): Uint8Array;
}
export class Mosaic {
    static TYPE_HINTS: {
        mosaicId: string;
        amount: string;
    };
    static deserialize(payload: any): Mosaic;
    _mosaicId: MosaicId;
    _amount: Amount;
    set mosaicId(arg: MosaicId);
    get mosaicId(): MosaicId;
    set amount(arg: Amount);
    get amount(): Amount;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class UnresolvedMosaic {
    static TYPE_HINTS: {
        mosaicId: string;
        amount: string;
    };
    static deserialize(payload: any): UnresolvedMosaic;
    _mosaicId: UnresolvedMosaicId;
    _amount: Amount;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set amount(arg: Amount);
    get amount(): Amount;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class LinkAction {
    static UNLINK: LinkAction;
    static LINK: LinkAction;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class NetworkType {
    static MAINNET: NetworkType;
    static TESTNET: NetworkType;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class TransactionType {
    static ACCOUNT_KEY_LINK: TransactionType;
    static NODE_KEY_LINK: TransactionType;
    static AGGREGATE_COMPLETE: TransactionType;
    static AGGREGATE_BONDED: TransactionType;
    static VOTING_KEY_LINK: TransactionType;
    static VRF_KEY_LINK: TransactionType;
    static HASH_LOCK: TransactionType;
    static SECRET_LOCK: TransactionType;
    static SECRET_PROOF: TransactionType;
    static ACCOUNT_METADATA: TransactionType;
    static MOSAIC_METADATA: TransactionType;
    static NAMESPACE_METADATA: TransactionType;
    static MOSAIC_DEFINITION: TransactionType;
    static MOSAIC_SUPPLY_CHANGE: TransactionType;
    static MOSAIC_SUPPLY_REVOCATION: TransactionType;
    static MULTISIG_ACCOUNT_MODIFICATION: TransactionType;
    static ADDRESS_ALIAS: TransactionType;
    static MOSAIC_ALIAS: TransactionType;
    static NAMESPACE_REGISTRATION: TransactionType;
    static ACCOUNT_ADDRESS_RESTRICTION: TransactionType;
    static ACCOUNT_MOSAIC_RESTRICTION: TransactionType;
    static ACCOUNT_OPERATION_RESTRICTION: TransactionType;
    static MOSAIC_ADDRESS_RESTRICTION: TransactionType;
    static MOSAIC_GLOBAL_RESTRICTION: TransactionType;
    static TRANSFER: TransactionType;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class Transaction {
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
    };
    static deserialize(payload: any): Transaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedTransaction {
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
    };
    static deserialize(payload: any): EmbeddedTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AccountKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        linkedPublicKey: string;
        linkAction: string;
    };
    static deserialize(payload: any): AccountKeyLinkTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _linkedPublicKey: PublicKey;
    _linkAction: LinkAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set linkedPublicKey(arg: PublicKey);
    get linkedPublicKey(): PublicKey;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedAccountKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        linkedPublicKey: string;
        linkAction: string;
    };
    static deserialize(payload: any): EmbeddedAccountKeyLinkTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _linkedPublicKey: PublicKey;
    _linkAction: LinkAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set linkedPublicKey(arg: PublicKey);
    get linkedPublicKey(): PublicKey;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class NodeKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        linkedPublicKey: string;
        linkAction: string;
    };
    static deserialize(payload: any): NodeKeyLinkTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _linkedPublicKey: PublicKey;
    _linkAction: LinkAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set linkedPublicKey(arg: PublicKey);
    get linkedPublicKey(): PublicKey;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedNodeKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        linkedPublicKey: string;
        linkAction: string;
    };
    static deserialize(payload: any): EmbeddedNodeKeyLinkTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _linkedPublicKey: PublicKey;
    _linkAction: LinkAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set linkedPublicKey(arg: PublicKey);
    get linkedPublicKey(): PublicKey;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class Cosignature {
    static TYPE_HINTS: {
        signerPublicKey: string;
        signature: string;
    };
    static deserialize(payload: any): Cosignature;
    _version: bigint;
    _signerPublicKey: PublicKey;
    _signature: Signature;
    set version(arg: bigint);
    get version(): bigint;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set signature(arg: Signature);
    get signature(): Signature;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class DetachedCosignature {
    static TYPE_HINTS: {
        signerPublicKey: string;
        signature: string;
        parentHash: string;
    };
    static deserialize(payload: any): DetachedCosignature;
    _version: bigint;
    _signerPublicKey: PublicKey;
    _signature: Signature;
    _parentHash: Hash256;
    set version(arg: bigint);
    get version(): bigint;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set signature(arg: Signature);
    get signature(): Signature;
    set parentHash(arg: Hash256);
    get parentHash(): Hash256;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AggregateCompleteTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        transactionsHash: string;
        transactions: string;
        cosignatures: string;
    };
    static deserialize(payload: any): AggregateCompleteTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _transactionsHash: Hash256;
    _transactions: any[];
    _cosignatures: any[];
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _aggregateTransactionHeaderReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set transactionsHash(arg: Hash256);
    get transactionsHash(): Hash256;
    set transactions(arg: any[]);
    get transactions(): any[];
    set cosignatures(arg: any[]);
    get cosignatures(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AggregateBondedTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        transactionsHash: string;
        transactions: string;
        cosignatures: string;
    };
    static deserialize(payload: any): AggregateBondedTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _transactionsHash: Hash256;
    _transactions: any[];
    _cosignatures: any[];
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _aggregateTransactionHeaderReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set transactionsHash(arg: Hash256);
    get transactionsHash(): Hash256;
    set transactions(arg: any[]);
    get transactions(): any[];
    set cosignatures(arg: any[]);
    get cosignatures(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class VotingKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        linkedPublicKey: string;
        startEpoch: string;
        endEpoch: string;
        linkAction: string;
    };
    static deserialize(payload: any): VotingKeyLinkTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _linkedPublicKey: VotingPublicKey;
    _startEpoch: FinalizationEpoch;
    _endEpoch: FinalizationEpoch;
    _linkAction: LinkAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set linkedPublicKey(arg: VotingPublicKey);
    get linkedPublicKey(): VotingPublicKey;
    set startEpoch(arg: FinalizationEpoch);
    get startEpoch(): FinalizationEpoch;
    set endEpoch(arg: FinalizationEpoch);
    get endEpoch(): FinalizationEpoch;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedVotingKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        linkedPublicKey: string;
        startEpoch: string;
        endEpoch: string;
        linkAction: string;
    };
    static deserialize(payload: any): EmbeddedVotingKeyLinkTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _linkedPublicKey: VotingPublicKey;
    _startEpoch: FinalizationEpoch;
    _endEpoch: FinalizationEpoch;
    _linkAction: LinkAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set linkedPublicKey(arg: VotingPublicKey);
    get linkedPublicKey(): VotingPublicKey;
    set startEpoch(arg: FinalizationEpoch);
    get startEpoch(): FinalizationEpoch;
    set endEpoch(arg: FinalizationEpoch);
    get endEpoch(): FinalizationEpoch;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class VrfKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        linkedPublicKey: string;
        linkAction: string;
    };
    static deserialize(payload: any): VrfKeyLinkTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _linkedPublicKey: PublicKey;
    _linkAction: LinkAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set linkedPublicKey(arg: PublicKey);
    get linkedPublicKey(): PublicKey;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedVrfKeyLinkTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        linkedPublicKey: string;
        linkAction: string;
    };
    static deserialize(payload: any): EmbeddedVrfKeyLinkTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _linkedPublicKey: PublicKey;
    _linkAction: LinkAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set linkedPublicKey(arg: PublicKey);
    get linkedPublicKey(): PublicKey;
    set linkAction(arg: LinkAction);
    get linkAction(): LinkAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class HashLockTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        mosaic: string;
        duration: string;
        hash: string;
    };
    static deserialize(payload: any): HashLockTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _mosaic: UnresolvedMosaic;
    _duration: BlockDuration;
    _hash: Hash256;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set mosaic(arg: UnresolvedMosaic);
    get mosaic(): UnresolvedMosaic;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set hash(arg: Hash256);
    get hash(): Hash256;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedHashLockTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        mosaic: string;
        duration: string;
        hash: string;
    };
    static deserialize(payload: any): EmbeddedHashLockTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _mosaic: UnresolvedMosaic;
    _duration: BlockDuration;
    _hash: Hash256;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set mosaic(arg: UnresolvedMosaic);
    get mosaic(): UnresolvedMosaic;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set hash(arg: Hash256);
    get hash(): Hash256;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class LockHashAlgorithm {
    static SHA3_256: LockHashAlgorithm;
    static HASH_160: LockHashAlgorithm;
    static HASH_256: LockHashAlgorithm;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class SecretLockTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        recipientAddress: string;
        secret: string;
        mosaic: string;
        duration: string;
        hashAlgorithm: string;
    };
    static deserialize(payload: any): SecretLockTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _recipientAddress: UnresolvedAddress;
    _secret: Hash256;
    _mosaic: UnresolvedMosaic;
    _duration: BlockDuration;
    _hashAlgorithm: LockHashAlgorithm;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set recipientAddress(arg: UnresolvedAddress);
    get recipientAddress(): UnresolvedAddress;
    set secret(arg: Hash256);
    get secret(): Hash256;
    set mosaic(arg: UnresolvedMosaic);
    get mosaic(): UnresolvedMosaic;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set hashAlgorithm(arg: LockHashAlgorithm);
    get hashAlgorithm(): LockHashAlgorithm;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedSecretLockTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        recipientAddress: string;
        secret: string;
        mosaic: string;
        duration: string;
        hashAlgorithm: string;
    };
    static deserialize(payload: any): EmbeddedSecretLockTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _recipientAddress: UnresolvedAddress;
    _secret: Hash256;
    _mosaic: UnresolvedMosaic;
    _duration: BlockDuration;
    _hashAlgorithm: LockHashAlgorithm;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set recipientAddress(arg: UnresolvedAddress);
    get recipientAddress(): UnresolvedAddress;
    set secret(arg: Hash256);
    get secret(): Hash256;
    set mosaic(arg: UnresolvedMosaic);
    get mosaic(): UnresolvedMosaic;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set hashAlgorithm(arg: LockHashAlgorithm);
    get hashAlgorithm(): LockHashAlgorithm;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class SecretProofTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        recipientAddress: string;
        secret: string;
        hashAlgorithm: string;
        proof: string;
    };
    static deserialize(payload: any): SecretProofTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _recipientAddress: UnresolvedAddress;
    _secret: Hash256;
    _hashAlgorithm: LockHashAlgorithm;
    _proof: Uint8Array;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set recipientAddress(arg: UnresolvedAddress);
    get recipientAddress(): UnresolvedAddress;
    set secret(arg: Hash256);
    get secret(): Hash256;
    set hashAlgorithm(arg: LockHashAlgorithm);
    get hashAlgorithm(): LockHashAlgorithm;
    set proof(arg: Uint8Array);
    get proof(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedSecretProofTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        recipientAddress: string;
        secret: string;
        hashAlgorithm: string;
        proof: string;
    };
    static deserialize(payload: any): EmbeddedSecretProofTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _recipientAddress: UnresolvedAddress;
    _secret: Hash256;
    _hashAlgorithm: LockHashAlgorithm;
    _proof: Uint8Array;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set recipientAddress(arg: UnresolvedAddress);
    get recipientAddress(): UnresolvedAddress;
    set secret(arg: Hash256);
    get secret(): Hash256;
    set hashAlgorithm(arg: LockHashAlgorithm);
    get hashAlgorithm(): LockHashAlgorithm;
    set proof(arg: Uint8Array);
    get proof(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AccountMetadataTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        targetAddress: string;
        value: string;
    };
    static deserialize(payload: any): AccountMetadataTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _targetAddress: UnresolvedAddress;
    _scopedMetadataKey: bigint;
    _valueSizeDelta: number;
    _value: Uint8Array;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    set scopedMetadataKey(arg: bigint);
    get scopedMetadataKey(): bigint;
    set valueSizeDelta(arg: number);
    get valueSizeDelta(): number;
    set value(arg: Uint8Array);
    get value(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedAccountMetadataTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        targetAddress: string;
        value: string;
    };
    static deserialize(payload: any): EmbeddedAccountMetadataTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _targetAddress: UnresolvedAddress;
    _scopedMetadataKey: bigint;
    _valueSizeDelta: number;
    _value: Uint8Array;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    set scopedMetadataKey(arg: bigint);
    get scopedMetadataKey(): bigint;
    set valueSizeDelta(arg: number);
    get valueSizeDelta(): number;
    set value(arg: Uint8Array);
    get value(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicMetadataTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        targetAddress: string;
        targetMosaicId: string;
        value: string;
    };
    static deserialize(payload: any): MosaicMetadataTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _targetAddress: UnresolvedAddress;
    _scopedMetadataKey: bigint;
    _targetMosaicId: UnresolvedMosaicId;
    _valueSizeDelta: number;
    _value: Uint8Array;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    set scopedMetadataKey(arg: bigint);
    get scopedMetadataKey(): bigint;
    set targetMosaicId(arg: UnresolvedMosaicId);
    get targetMosaicId(): UnresolvedMosaicId;
    set valueSizeDelta(arg: number);
    get valueSizeDelta(): number;
    set value(arg: Uint8Array);
    get value(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicMetadataTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        targetAddress: string;
        targetMosaicId: string;
        value: string;
    };
    static deserialize(payload: any): EmbeddedMosaicMetadataTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _targetAddress: UnresolvedAddress;
    _scopedMetadataKey: bigint;
    _targetMosaicId: UnresolvedMosaicId;
    _valueSizeDelta: number;
    _value: Uint8Array;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    set scopedMetadataKey(arg: bigint);
    get scopedMetadataKey(): bigint;
    set targetMosaicId(arg: UnresolvedMosaicId);
    get targetMosaicId(): UnresolvedMosaicId;
    set valueSizeDelta(arg: number);
    get valueSizeDelta(): number;
    set value(arg: Uint8Array);
    get value(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class NamespaceId extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): NamespaceId;
    constructor(namespaceId?: bigint);
    serialize(): Uint8Array;
}
export class NamespaceRegistrationType {
    static ROOT: NamespaceRegistrationType;
    static CHILD: NamespaceRegistrationType;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AliasAction {
    static UNLINK: AliasAction;
    static LINK: AliasAction;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class NamespaceMetadataTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        targetAddress: string;
        targetNamespaceId: string;
        value: string;
    };
    static deserialize(payload: any): NamespaceMetadataTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _targetAddress: UnresolvedAddress;
    _scopedMetadataKey: bigint;
    _targetNamespaceId: NamespaceId;
    _valueSizeDelta: number;
    _value: Uint8Array;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    set scopedMetadataKey(arg: bigint);
    get scopedMetadataKey(): bigint;
    set targetNamespaceId(arg: NamespaceId);
    get targetNamespaceId(): NamespaceId;
    set valueSizeDelta(arg: number);
    get valueSizeDelta(): number;
    set value(arg: Uint8Array);
    get value(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedNamespaceMetadataTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        targetAddress: string;
        targetNamespaceId: string;
        value: string;
    };
    static deserialize(payload: any): EmbeddedNamespaceMetadataTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _targetAddress: UnresolvedAddress;
    _scopedMetadataKey: bigint;
    _targetNamespaceId: NamespaceId;
    _valueSizeDelta: number;
    _value: Uint8Array;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    set scopedMetadataKey(arg: bigint);
    get scopedMetadataKey(): bigint;
    set targetNamespaceId(arg: NamespaceId);
    get targetNamespaceId(): NamespaceId;
    set valueSizeDelta(arg: number);
    get valueSizeDelta(): number;
    set value(arg: Uint8Array);
    get value(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicNonce extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): MosaicNonce;
    constructor(mosaicNonce?: number);
    serialize(): Uint8Array;
}
export class MosaicFlags {
    static NONE: MosaicFlags;
    static SUPPLY_MUTABLE: MosaicFlags;
    static TRANSFERABLE: MosaicFlags;
    static RESTRICTABLE: MosaicFlags;
    static REVOKABLE: MosaicFlags;
    static deserialize(payload: any): MosaicFlags;
    constructor(value: any);
    value: any;
    has(flag: any): boolean;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicSupplyChangeAction {
    static DECREASE: MosaicSupplyChangeAction;
    static INCREASE: MosaicSupplyChangeAction;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicDefinitionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        id: string;
        duration: string;
        nonce: string;
        flags: string;
    };
    static deserialize(payload: any): MosaicDefinitionTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _id: MosaicId;
    _duration: BlockDuration;
    _nonce: MosaicNonce;
    _flags: MosaicFlags;
    _divisibility: number;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set id(arg: MosaicId);
    get id(): MosaicId;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set nonce(arg: MosaicNonce);
    get nonce(): MosaicNonce;
    set flags(arg: MosaicFlags);
    get flags(): MosaicFlags;
    set divisibility(arg: number);
    get divisibility(): number;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicDefinitionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        id: string;
        duration: string;
        nonce: string;
        flags: string;
    };
    static deserialize(payload: any): EmbeddedMosaicDefinitionTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _id: MosaicId;
    _duration: BlockDuration;
    _nonce: MosaicNonce;
    _flags: MosaicFlags;
    _divisibility: number;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set id(arg: MosaicId);
    get id(): MosaicId;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set nonce(arg: MosaicNonce);
    get nonce(): MosaicNonce;
    set flags(arg: MosaicFlags);
    get flags(): MosaicFlags;
    set divisibility(arg: number);
    get divisibility(): number;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicSupplyChangeTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        mosaicId: string;
        delta: string;
        action: string;
    };
    static deserialize(payload: any): MosaicSupplyChangeTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _mosaicId: UnresolvedMosaicId;
    _delta: Amount;
    _action: MosaicSupplyChangeAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set delta(arg: Amount);
    get delta(): Amount;
    set action(arg: MosaicSupplyChangeAction);
    get action(): MosaicSupplyChangeAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicSupplyChangeTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        mosaicId: string;
        delta: string;
        action: string;
    };
    static deserialize(payload: any): EmbeddedMosaicSupplyChangeTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _mosaicId: UnresolvedMosaicId;
    _delta: Amount;
    _action: MosaicSupplyChangeAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set delta(arg: Amount);
    get delta(): Amount;
    set action(arg: MosaicSupplyChangeAction);
    get action(): MosaicSupplyChangeAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicSupplyRevocationTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        sourceAddress: string;
        mosaic: string;
    };
    static deserialize(payload: any): MosaicSupplyRevocationTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _sourceAddress: UnresolvedAddress;
    _mosaic: UnresolvedMosaic;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set sourceAddress(arg: UnresolvedAddress);
    get sourceAddress(): UnresolvedAddress;
    set mosaic(arg: UnresolvedMosaic);
    get mosaic(): UnresolvedMosaic;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicSupplyRevocationTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        sourceAddress: string;
        mosaic: string;
    };
    static deserialize(payload: any): EmbeddedMosaicSupplyRevocationTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _sourceAddress: UnresolvedAddress;
    _mosaic: UnresolvedMosaic;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set sourceAddress(arg: UnresolvedAddress);
    get sourceAddress(): UnresolvedAddress;
    set mosaic(arg: UnresolvedMosaic);
    get mosaic(): UnresolvedMosaic;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MultisigAccountModificationTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        addressAdditions: string;
        addressDeletions: string;
    };
    static deserialize(payload: any): MultisigAccountModificationTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _minRemovalDelta: number;
    _minApprovalDelta: number;
    _addressAdditions: any[];
    _addressDeletions: any[];
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _multisigAccountModificationTransactionBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set minRemovalDelta(arg: number);
    get minRemovalDelta(): number;
    set minApprovalDelta(arg: number);
    get minApprovalDelta(): number;
    set addressAdditions(arg: any[]);
    get addressAdditions(): any[];
    set addressDeletions(arg: any[]);
    get addressDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMultisigAccountModificationTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        addressAdditions: string;
        addressDeletions: string;
    };
    static deserialize(payload: any): EmbeddedMultisigAccountModificationTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _minRemovalDelta: number;
    _minApprovalDelta: number;
    _addressAdditions: any[];
    _addressDeletions: any[];
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _multisigAccountModificationTransactionBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set minRemovalDelta(arg: number);
    get minRemovalDelta(): number;
    set minApprovalDelta(arg: number);
    get minApprovalDelta(): number;
    set addressAdditions(arg: any[]);
    get addressAdditions(): any[];
    set addressDeletions(arg: any[]);
    get addressDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AddressAliasTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        namespaceId: string;
        address: string;
        aliasAction: string;
    };
    static deserialize(payload: any): AddressAliasTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _namespaceId: NamespaceId;
    _address: Address;
    _aliasAction: AliasAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set namespaceId(arg: NamespaceId);
    get namespaceId(): NamespaceId;
    set address(arg: Address);
    get address(): Address;
    set aliasAction(arg: AliasAction);
    get aliasAction(): AliasAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedAddressAliasTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        namespaceId: string;
        address: string;
        aliasAction: string;
    };
    static deserialize(payload: any): EmbeddedAddressAliasTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _namespaceId: NamespaceId;
    _address: Address;
    _aliasAction: AliasAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set namespaceId(arg: NamespaceId);
    get namespaceId(): NamespaceId;
    set address(arg: Address);
    get address(): Address;
    set aliasAction(arg: AliasAction);
    get aliasAction(): AliasAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicAliasTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        namespaceId: string;
        mosaicId: string;
        aliasAction: string;
    };
    static deserialize(payload: any): MosaicAliasTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _namespaceId: NamespaceId;
    _mosaicId: MosaicId;
    _aliasAction: AliasAction;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set namespaceId(arg: NamespaceId);
    get namespaceId(): NamespaceId;
    set mosaicId(arg: MosaicId);
    get mosaicId(): MosaicId;
    set aliasAction(arg: AliasAction);
    get aliasAction(): AliasAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicAliasTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        namespaceId: string;
        mosaicId: string;
        aliasAction: string;
    };
    static deserialize(payload: any): EmbeddedMosaicAliasTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _namespaceId: NamespaceId;
    _mosaicId: MosaicId;
    _aliasAction: AliasAction;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set namespaceId(arg: NamespaceId);
    get namespaceId(): NamespaceId;
    set mosaicId(arg: MosaicId);
    get mosaicId(): MosaicId;
    set aliasAction(arg: AliasAction);
    get aliasAction(): AliasAction;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class NamespaceRegistrationTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        duration: string;
        parentId: string;
        id: string;
        registrationType: string;
        name: string;
    };
    static deserialize(payload: any): NamespaceRegistrationTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _duration: BlockDuration;
    _parentId: NamespaceId;
    _id: NamespaceId;
    _registrationType: NamespaceRegistrationType;
    _name: Uint8Array;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set parentId(arg: NamespaceId);
    get parentId(): NamespaceId;
    set id(arg: NamespaceId);
    get id(): NamespaceId;
    set registrationType(arg: NamespaceRegistrationType);
    get registrationType(): NamespaceRegistrationType;
    set name(arg: Uint8Array);
    get name(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedNamespaceRegistrationTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        duration: string;
        parentId: string;
        id: string;
        registrationType: string;
        name: string;
    };
    static deserialize(payload: any): EmbeddedNamespaceRegistrationTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _duration: BlockDuration;
    _parentId: NamespaceId;
    _id: NamespaceId;
    _registrationType: NamespaceRegistrationType;
    _name: Uint8Array;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set duration(arg: BlockDuration);
    get duration(): BlockDuration;
    set parentId(arg: NamespaceId);
    get parentId(): NamespaceId;
    set id(arg: NamespaceId);
    get id(): NamespaceId;
    set registrationType(arg: NamespaceRegistrationType);
    get registrationType(): NamespaceRegistrationType;
    set name(arg: Uint8Array);
    get name(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AccountRestrictionFlags {
    static ADDRESS: AccountRestrictionFlags;
    static MOSAIC_ID: AccountRestrictionFlags;
    static TRANSACTION_TYPE: AccountRestrictionFlags;
    static OUTGOING: AccountRestrictionFlags;
    static BLOCK: AccountRestrictionFlags;
    static deserialize(payload: any): AccountRestrictionFlags;
    constructor(value: any);
    value: any;
    has(flag: any): boolean;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AccountAddressRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        restrictionFlags: string;
        restrictionAdditions: string;
        restrictionDeletions: string;
    };
    static deserialize(payload: any): AccountAddressRestrictionTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _restrictionFlags: AccountRestrictionFlags;
    _restrictionAdditions: any[];
    _restrictionDeletions: any[];
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _accountRestrictionTransactionBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set restrictionFlags(arg: AccountRestrictionFlags);
    get restrictionFlags(): AccountRestrictionFlags;
    set restrictionAdditions(arg: any[]);
    get restrictionAdditions(): any[];
    set restrictionDeletions(arg: any[]);
    get restrictionDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedAccountAddressRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        restrictionFlags: string;
        restrictionAdditions: string;
        restrictionDeletions: string;
    };
    static deserialize(payload: any): EmbeddedAccountAddressRestrictionTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _restrictionFlags: AccountRestrictionFlags;
    _restrictionAdditions: any[];
    _restrictionDeletions: any[];
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _accountRestrictionTransactionBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set restrictionFlags(arg: AccountRestrictionFlags);
    get restrictionFlags(): AccountRestrictionFlags;
    set restrictionAdditions(arg: any[]);
    get restrictionAdditions(): any[];
    set restrictionDeletions(arg: any[]);
    get restrictionDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AccountMosaicRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        restrictionFlags: string;
        restrictionAdditions: string;
        restrictionDeletions: string;
    };
    static deserialize(payload: any): AccountMosaicRestrictionTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _restrictionFlags: AccountRestrictionFlags;
    _restrictionAdditions: any[];
    _restrictionDeletions: any[];
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _accountRestrictionTransactionBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set restrictionFlags(arg: AccountRestrictionFlags);
    get restrictionFlags(): AccountRestrictionFlags;
    set restrictionAdditions(arg: any[]);
    get restrictionAdditions(): any[];
    set restrictionDeletions(arg: any[]);
    get restrictionDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedAccountMosaicRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        restrictionFlags: string;
        restrictionAdditions: string;
        restrictionDeletions: string;
    };
    static deserialize(payload: any): EmbeddedAccountMosaicRestrictionTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _restrictionFlags: AccountRestrictionFlags;
    _restrictionAdditions: any[];
    _restrictionDeletions: any[];
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _accountRestrictionTransactionBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set restrictionFlags(arg: AccountRestrictionFlags);
    get restrictionFlags(): AccountRestrictionFlags;
    set restrictionAdditions(arg: any[]);
    get restrictionAdditions(): any[];
    set restrictionDeletions(arg: any[]);
    get restrictionDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class AccountOperationRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        restrictionFlags: string;
        restrictionAdditions: string;
        restrictionDeletions: string;
    };
    static deserialize(payload: any): AccountOperationRestrictionTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _restrictionFlags: AccountRestrictionFlags;
    _restrictionAdditions: any[];
    _restrictionDeletions: any[];
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _accountRestrictionTransactionBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set restrictionFlags(arg: AccountRestrictionFlags);
    get restrictionFlags(): AccountRestrictionFlags;
    set restrictionAdditions(arg: any[]);
    get restrictionAdditions(): any[];
    set restrictionDeletions(arg: any[]);
    get restrictionDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedAccountOperationRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        restrictionFlags: string;
        restrictionAdditions: string;
        restrictionDeletions: string;
    };
    static deserialize(payload: any): EmbeddedAccountOperationRestrictionTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _restrictionFlags: AccountRestrictionFlags;
    _restrictionAdditions: any[];
    _restrictionDeletions: any[];
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _accountRestrictionTransactionBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set restrictionFlags(arg: AccountRestrictionFlags);
    get restrictionFlags(): AccountRestrictionFlags;
    set restrictionAdditions(arg: any[]);
    get restrictionAdditions(): any[];
    set restrictionDeletions(arg: any[]);
    get restrictionDeletions(): any[];
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicAddressRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        mosaicId: string;
        targetAddress: string;
    };
    static deserialize(payload: any): MosaicAddressRestrictionTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _mosaicId: UnresolvedMosaicId;
    _restrictionKey: bigint;
    _previousRestrictionValue: bigint;
    _newRestrictionValue: bigint;
    _targetAddress: UnresolvedAddress;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set restrictionKey(arg: bigint);
    get restrictionKey(): bigint;
    set previousRestrictionValue(arg: bigint);
    get previousRestrictionValue(): bigint;
    set newRestrictionValue(arg: bigint);
    get newRestrictionValue(): bigint;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicAddressRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        mosaicId: string;
        targetAddress: string;
    };
    static deserialize(payload: any): EmbeddedMosaicAddressRestrictionTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _mosaicId: UnresolvedMosaicId;
    _restrictionKey: bigint;
    _previousRestrictionValue: bigint;
    _newRestrictionValue: bigint;
    _targetAddress: UnresolvedAddress;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set restrictionKey(arg: bigint);
    get restrictionKey(): bigint;
    set previousRestrictionValue(arg: bigint);
    get previousRestrictionValue(): bigint;
    set newRestrictionValue(arg: bigint);
    get newRestrictionValue(): bigint;
    set targetAddress(arg: UnresolvedAddress);
    get targetAddress(): UnresolvedAddress;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicRestrictionKey extends BaseValue {
    static SIZE: number;
    static deserialize(payload: any): MosaicRestrictionKey;
    constructor(mosaicRestrictionKey?: bigint);
    serialize(): Uint8Array;
}
export class MosaicRestrictionType {
    static NONE: MosaicRestrictionType;
    static EQ: MosaicRestrictionType;
    static NE: MosaicRestrictionType;
    static LT: MosaicRestrictionType;
    static LE: MosaicRestrictionType;
    static GT: MosaicRestrictionType;
    static GE: MosaicRestrictionType;
    static valueToKey(value: any): string;
    static fromValue(value: any): any;
    static deserialize(payload: any): any;
    constructor(value: any);
    value: any;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class MosaicGlobalRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        mosaicId: string;
        referenceMosaicId: string;
        previousRestrictionType: string;
        newRestrictionType: string;
    };
    static deserialize(payload: any): MosaicGlobalRestrictionTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _mosaicId: UnresolvedMosaicId;
    _referenceMosaicId: UnresolvedMosaicId;
    _restrictionKey: bigint;
    _previousRestrictionValue: bigint;
    _newRestrictionValue: bigint;
    _previousRestrictionType: MosaicRestrictionType;
    _newRestrictionType: MosaicRestrictionType;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set referenceMosaicId(arg: UnresolvedMosaicId);
    get referenceMosaicId(): UnresolvedMosaicId;
    set restrictionKey(arg: bigint);
    get restrictionKey(): bigint;
    set previousRestrictionValue(arg: bigint);
    get previousRestrictionValue(): bigint;
    set newRestrictionValue(arg: bigint);
    get newRestrictionValue(): bigint;
    set previousRestrictionType(arg: MosaicRestrictionType);
    get previousRestrictionType(): MosaicRestrictionType;
    set newRestrictionType(arg: MosaicRestrictionType);
    get newRestrictionType(): MosaicRestrictionType;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedMosaicGlobalRestrictionTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        mosaicId: string;
        referenceMosaicId: string;
        previousRestrictionType: string;
        newRestrictionType: string;
    };
    static deserialize(payload: any): EmbeddedMosaicGlobalRestrictionTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _mosaicId: UnresolvedMosaicId;
    _referenceMosaicId: UnresolvedMosaicId;
    _restrictionKey: bigint;
    _previousRestrictionValue: bigint;
    _newRestrictionValue: bigint;
    _previousRestrictionType: MosaicRestrictionType;
    _newRestrictionType: MosaicRestrictionType;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set mosaicId(arg: UnresolvedMosaicId);
    get mosaicId(): UnresolvedMosaicId;
    set referenceMosaicId(arg: UnresolvedMosaicId);
    get referenceMosaicId(): UnresolvedMosaicId;
    set restrictionKey(arg: bigint);
    get restrictionKey(): bigint;
    set previousRestrictionValue(arg: bigint);
    get previousRestrictionValue(): bigint;
    set newRestrictionValue(arg: bigint);
    get newRestrictionValue(): bigint;
    set previousRestrictionType(arg: MosaicRestrictionType);
    get previousRestrictionType(): MosaicRestrictionType;
    set newRestrictionType(arg: MosaicRestrictionType);
    get newRestrictionType(): MosaicRestrictionType;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class TransferTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signature: string;
        signerPublicKey: string;
        network: string;
        type: string;
        fee: string;
        deadline: string;
        recipientAddress: string;
        mosaics: string;
        message: string;
    };
    static deserialize(payload: any): TransferTransaction;
    _signature: Signature;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _fee: Amount;
    _deadline: Timestamp;
    _recipientAddress: UnresolvedAddress;
    _mosaics: any[];
    _message: Uint8Array;
    _verifiableEntityHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _transferTransactionBodyReserved_1: number;
    _transferTransactionBodyReserved_2: number;
    set signature(arg: Signature);
    get signature(): Signature;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set fee(arg: Amount);
    get fee(): Amount;
    set deadline(arg: Timestamp);
    get deadline(): Timestamp;
    set recipientAddress(arg: UnresolvedAddress);
    get recipientAddress(): UnresolvedAddress;
    set mosaics(arg: any[]);
    get mosaics(): any[];
    set message(arg: Uint8Array);
    get message(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class EmbeddedTransferTransaction {
    static TRANSACTION_VERSION: number;
    static TRANSACTION_TYPE: TransactionType;
    static TYPE_HINTS: {
        signerPublicKey: string;
        network: string;
        type: string;
        recipientAddress: string;
        mosaics: string;
        message: string;
    };
    static deserialize(payload: any): EmbeddedTransferTransaction;
    _signerPublicKey: PublicKey;
    _version: number;
    _network: NetworkType;
    _type: TransactionType;
    _recipientAddress: UnresolvedAddress;
    _mosaics: any[];
    _message: Uint8Array;
    _embeddedTransactionHeaderReserved_1: number;
    _entityBodyReserved_1: number;
    _transferTransactionBodyReserved_1: number;
    _transferTransactionBodyReserved_2: number;
    set signerPublicKey(arg: PublicKey);
    get signerPublicKey(): PublicKey;
    set version(arg: number);
    get version(): number;
    set network(arg: NetworkType);
    get network(): NetworkType;
    set type(arg: TransactionType);
    get type(): TransactionType;
    set recipientAddress(arg: UnresolvedAddress);
    get recipientAddress(): UnresolvedAddress;
    set mosaics(arg: any[]);
    get mosaics(): any[];
    set message(arg: Uint8Array);
    get message(): Uint8Array;
    get size(): number;
    serialize(): Uint8Array;
    toString(): string;
}
export class TransactionFactory {
    static toKey(values: any): any;
    static deserialize(payload: any): any;
    static createByName(entityName: any): any;
}
export class EmbeddedTransactionFactory {
    static toKey(values: any): any;
    static deserialize(payload: any): any;
    static createByName(entityName: any): any;
}
import { BaseValue } from "../BaseValue";
import { ByteArray } from "../ByteArray";
